using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MinimalWorker.Generators;

/// <summary>
/// Emits strongly-typed, AOT-compatible code for background workers.
/// No reflection - generates direct method calls with DI resolution.
/// </summary>
internal static class WorkerEmitter
{
    /// <summary>
    /// Emits shared infrastructure code that doesn't depend on worker analysis.
    /// This is generated via RegisterPostInitializationOutput for better incrementality.
    /// </summary>
    public static string EmitSharedCode()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// MinimalWorker Source Generator - Shared Infrastructure");
        sb.AppendLine("// This file contains shared code that doesn't depend on worker analysis.");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Diagnostics;");
        sb.AppendLine("using System.Diagnostics.Metrics;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.AppendLine();
        sb.AppendLine("namespace MinimalWorker;");
        sb.AppendLine();

        // Emit ActivityExtensions
        EmitActivityExtensions(sb);

        // Emit MinimalWorkerObservability
        EmitObservability(sb);

        // Emit WorkerLogMessages
        EmitWorkerLogMessages(sb);

        // Emit TimeProvider extensions for timeout/retry support
        EmitTimeProviderExtensions(sb);

        return sb.ToString();
    }

    /// <summary>
    /// Emits worker-specific code based on analyzed worker invocations.
    /// </summary>
    public static string EmitSource(List<WorkerInvocationModel> workers)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// MinimalWorker Source Generator - Worker Initializers");
        sb.AppendLine("// AOT-compatible background worker registration");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Diagnostics;");
        sb.AppendLine("using System.Diagnostics.Metrics;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.Hosting;");
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.AppendLine();
        sb.AppendLine("namespace MinimalWorker;");
        sb.AppendLine();

        // Emit the extension method that wires up all workers
        EmitWorkerExtension(sb, workers);

        return sb.ToString();
    }

    private static void EmitActivityExtensions(StringBuilder sb)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Extension methods for Activity to support exception recording.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class ActivityExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Records an exception on the activity following OpenTelemetry semantic conventions.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static void RecordException(this Activity? activity, Exception exception)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (activity == null) return;");
        sb.AppendLine();
        sb.AppendLine("        // Cache exception type to avoid multiple reflection calls");
        sb.AppendLine("        var exceptionType = exception.GetType();");
        sb.AppendLine("        activity.SetTag(\"exception.type\", exceptionType.FullName);");
        sb.AppendLine("        activity.SetTag(\"exception.message\", exception.Message);");
        sb.AppendLine();
        sb.AppendLine("        // Only allocate stacktrace string if activity is actually recording");
        sb.AppendLine("        if (activity.IsAllDataRequested)");
        sb.AppendLine("        {");
        sb.AppendLine("            activity.SetTag(\"exception.stacktrace\", exception.ToString());");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitObservability(StringBuilder sb)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Observability instruments for MinimalWorker.");
        sb.AppendLine("/// ActivitySource and Meter are automatically consumed by OpenTelemetry when configured.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class MinimalWorkerObservability");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// ActivitySource for distributed tracing.");
        sb.AppendLine("    /// Configure with: tracerProvider.AddSource(\"MinimalWorker\")");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly ActivitySource ActivitySource = new(\"MinimalWorker\", \"3.1.0\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Meter for metrics collection.");
        sb.AppendLine("    /// Configure with: meterProvider.AddMeter(\"MinimalWorker\")");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Meter Meter = new(\"MinimalWorker\", \"3.1.0\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Counter for total worker executions.");
        sb.AppendLine("    /// Dimensions: worker.id, worker.name, worker.type");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Counter<long> ExecutionCounter = Meter.CreateCounter<long>(");
        sb.AppendLine("        \"worker.executions\",");
        sb.AppendLine("        unit: \"{execution}\",");
        sb.AppendLine("        description: \"Total number of worker executions\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Counter for total worker errors.");
        sb.AppendLine("    /// Dimensions: worker.id, worker.name, worker.type, exception.type");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Counter<long> ErrorCounter = Meter.CreateCounter<long>(");
        sb.AppendLine("        \"worker.errors\",");
        sb.AppendLine("        unit: \"{error}\",");
        sb.AppendLine("        description: \"Total number of worker errors\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Histogram for worker execution duration.");
        sb.AppendLine("    /// Dimensions: worker.id, worker.name, worker.type");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Histogram<double> DurationHistogram = Meter.CreateHistogram<double>(");
        sb.AppendLine("        \"worker.duration\",");
        sb.AppendLine("        unit: \"ms\",");
        sb.AppendLine("        description: \"Duration of worker executions in milliseconds\");");
        sb.AppendLine();
        sb.AppendLine("    // Worker state tracking for observable gauges");
        sb.AppendLine("    private static readonly System.Collections.Concurrent.ConcurrentDictionary<string, WorkerState> _workerStates = new();");
        sb.AppendLine();
        sb.AppendLine("    // Cached snapshot for gauge enumeration optimization");
        sb.AppendLine("    private static WorkerState[]? _cachedSnapshot;");
        sb.AppendLine("    private static int _snapshotVersion;");
        sb.AppendLine("    private static int _currentVersion;");
        sb.AppendLine();
        sb.AppendLine("    internal sealed class WorkerState");
        sb.AppendLine("    {");
        sb.AppendLine("        public string WorkerId { get; set; } = string.Empty;");
        sb.AppendLine("        public string WorkerName { get; set; } = string.Empty;");
        sb.AppendLine("        public string WorkerType { get; set; } = string.Empty;");
        sb.AppendLine("        public bool IsActive { get; set; }");
        sb.AppendLine("        public long LastSuccessTimestamp { get; set; }");
        sb.AppendLine("        public long ConsecutiveFailures { get; set; }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets a cached snapshot of worker states, only re-allocating when workers are added/removed.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    private static WorkerState[] GetWorkerStatesSnapshot()");
        sb.AppendLine("    {");
        sb.AppendLine("        var version = Volatile.Read(ref _currentVersion);");
        sb.AppendLine("        var cached = _cachedSnapshot;");
        sb.AppendLine("        if (cached != null && _snapshotVersion == version)");
        sb.AppendLine("        {");
        sb.AppendLine("            return cached;");
        sb.AppendLine("        }");
        sb.AppendLine("        // Version changed or no cache - create new snapshot");
        sb.AppendLine("        var snapshot = _workerStates.Values.ToArray();");
        sb.AppendLine("        _cachedSnapshot = snapshot;");
        sb.AppendLine("        _snapshotVersion = version;");
        sb.AppendLine("        return snapshot;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    internal static void RegisterWorker(string workerId, string workerName, string workerType)");
        sb.AppendLine("    {");
        sb.AppendLine("        _workerStates[workerId] = new WorkerState");
        sb.AppendLine("        {");
        sb.AppendLine("            WorkerId = workerId,");
        sb.AppendLine("            WorkerName = workerName,");
        sb.AppendLine("            WorkerType = workerType,");
        sb.AppendLine("            IsActive = true,");
        sb.AppendLine("            LastSuccessTimestamp = 0,");
        sb.AppendLine("            ConsecutiveFailures = 0");
        sb.AppendLine("        };");
        sb.AppendLine("        // Invalidate cache when worker is registered");
        sb.AppendLine("        Interlocked.Increment(ref _currentVersion);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    internal static void RecordSuccess(string workerId)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_workerStates.TryGetValue(workerId, out var state))");
        sb.AppendLine("        {");
        sb.AppendLine("            state.LastSuccessTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds();");
        sb.AppendLine("            state.ConsecutiveFailures = 0;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    internal static void RecordFailure(string workerId)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_workerStates.TryGetValue(workerId, out var state))");
        sb.AppendLine("        {");
        sb.AppendLine("            state.ConsecutiveFailures++;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    internal static void DeactivateWorker(string workerId)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_workerStates.TryGetValue(workerId, out var state))");
        sb.AppendLine("        {");
        sb.AppendLine("            state.IsActive = false;");
        sb.AppendLine("        }");
        sb.AppendLine("        // Invalidate cache when worker is deactivated");
        sb.AppendLine("        Interlocked.Increment(ref _currentVersion);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Observable gauge for active workers.");
        sb.AppendLine("    /// Returns 1 if worker is running, 0 if stopped.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly ObservableGauge<int> ActiveWorkersGauge = Meter.CreateObservableGauge<int>(");
        sb.AppendLine("        \"worker.active\",");
        sb.AppendLine("        GetActiveWorkerMeasurements,");
        sb.AppendLine("        unit: \"{active}\",");
        sb.AppendLine("        description: \"Number of active workers (1 = running, 0 = stopped)\");");
        sb.AppendLine();
        sb.AppendLine("    private static System.Collections.Generic.IEnumerable<Measurement<int>> GetActiveWorkerMeasurements()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Use cached snapshot to avoid allocation on every metrics export");
        sb.AppendLine("        foreach (var state in GetWorkerStatesSnapshot())");
        sb.AppendLine("        {");
        sb.AppendLine("            var tags = new TagList");
        sb.AppendLine("            {");
        sb.AppendLine("                { \"worker.id\", state.WorkerId },");
        sb.AppendLine("                { \"worker.name\", state.WorkerName },");
        sb.AppendLine("                { \"worker.type\", state.WorkerType }");
        sb.AppendLine("            };");
        sb.AppendLine("            yield return new Measurement<int>(state.IsActive ? 1 : 0, tags);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Observable gauge for last successful execution timestamp.");
        sb.AppendLine("    /// Unix timestamp of the last successful execution.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly ObservableGauge<long> LastSuccessGauge = Meter.CreateObservableGauge<long>(");
        sb.AppendLine("        \"worker.last_success_time\",");
        sb.AppendLine("        GetLastSuccessMeasurements,");
        sb.AppendLine("        unit: \"s\",");
        sb.AppendLine("        description: \"Unix timestamp of last successful worker execution\");");
        sb.AppendLine();
        sb.AppendLine("    private static System.Collections.Generic.IEnumerable<Measurement<long>> GetLastSuccessMeasurements()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Use cached snapshot to avoid allocation on every metrics export");
        sb.AppendLine("        foreach (var state in GetWorkerStatesSnapshot())");
        sb.AppendLine("        {");
        sb.AppendLine("            if (state.LastSuccessTimestamp > 0)");
        sb.AppendLine("            {");
        sb.AppendLine("                var tags = new TagList");
        sb.AppendLine("                {");
        sb.AppendLine("                    { \"worker.id\", state.WorkerId },");
        sb.AppendLine("                    { \"worker.name\", state.WorkerName },");
        sb.AppendLine("                    { \"worker.type\", state.WorkerType }");
        sb.AppendLine("                };");
        sb.AppendLine("                yield return new Measurement<long>(state.LastSuccessTimestamp, tags);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Observable gauge for consecutive failures count.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly ObservableGauge<long> ConsecutiveFailuresGauge = Meter.CreateObservableGauge<long>(");
        sb.AppendLine("        \"worker.consecutive_failures\",");
        sb.AppendLine("        GetConsecutiveFailuresMeasurements,");
        sb.AppendLine("        unit: \"{failure}\",");
        sb.AppendLine("        description: \"Number of consecutive failures for each worker\");");
        sb.AppendLine();
        sb.AppendLine("    private static System.Collections.Generic.IEnumerable<Measurement<long>> GetConsecutiveFailuresMeasurements()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Use cached snapshot to avoid allocation on every metrics export");
        sb.AppendLine("        foreach (var state in GetWorkerStatesSnapshot())");
        sb.AppendLine("        {");
        sb.AppendLine("            var tags = new TagList");
        sb.AppendLine("            {");
        sb.AppendLine("                { \"worker.id\", state.WorkerId },");
        sb.AppendLine("                { \"worker.name\", state.WorkerName },");
        sb.AppendLine("                { \"worker.type\", state.WorkerType }");
        sb.AppendLine("            };");
        sb.AppendLine("            yield return new Measurement<long>(state.ConsecutiveFailures, tags);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitWorkerLogMessages(StringBuilder sb)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// High-performance, AOT-compatible logging messages for MinimalWorker.");
        sb.AppendLine("/// Uses LoggerMessage.Define for zero-allocation logging.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class WorkerLogMessages");
        sb.AppendLine("{");
        sb.AppendLine("    // Worker started messages");
        sb.AppendLine("    internal static readonly Action<ILogger, string, string, string, Exception?> WorkerStarted =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string>(LogLevel.Information, new EventId(1, \"WorkerStarted\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' started (Type: {WorkerType}, Id: {WorkerId})\");");
        sb.AppendLine();
        sb.AppendLine("    internal static readonly Action<ILogger, string, string, string, TimeSpan, Exception?> WorkerStartedWithSchedule =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string, TimeSpan>(LogLevel.Information, new EventId(2, \"WorkerStartedWithSchedule\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' started (Type: {WorkerType}, Id: {WorkerId}, Schedule: {Schedule})\");");
        sb.AppendLine();
        sb.AppendLine("    internal static readonly Action<ILogger, string, string, string, string, Exception?> WorkerStartedWithCron =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string, string>(LogLevel.Information, new EventId(3, \"WorkerStartedWithCron\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' started (Type: {WorkerType}, Id: {WorkerId}, CronExpression: {CronExpression})\");");
        sb.AppendLine();
        sb.AppendLine("    // Worker stopped message");
        sb.AppendLine("    internal static readonly Action<ILogger, string, string, string, Exception?> WorkerStopped =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string>(LogLevel.Information, new EventId(4, \"WorkerStopped\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' stopped (Type: {WorkerType}, Id: {WorkerId})\");");
        sb.AppendLine();
        sb.AppendLine("    // Worker execution failed messages");
        sb.AppendLine("    internal static readonly Action<ILogger, string, long, Exception?> WorkerExecutionFailedWithIteration =");
        sb.AppendLine("        LoggerMessage.Define<string, long>(LogLevel.Error, new EventId(5, \"WorkerExecutionFailedWithIteration\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' execution failed (Iteration: {Iteration})\");");
        sb.AppendLine();
        sb.AppendLine("    internal static readonly Action<ILogger, string, Exception?> WorkerExecutionFailed =");
        sb.AppendLine("        LoggerMessage.Define<string>(LogLevel.Error, new EventId(6, \"WorkerExecutionFailed\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' execution failed\");");
        sb.AppendLine();
        sb.AppendLine("    // Fatal error message");
        sb.AppendLine("    internal static readonly Action<ILogger, string, Exception?> WorkerFatalError =");
        sb.AppendLine("        LoggerMessage.Define<string>(LogLevel.Critical, new EventId(7, \"WorkerFatalError\"),");
        sb.AppendLine("            \"FATAL: Unhandled exception in background worker '{WorkerName}'. Application will terminate.\");");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitTimeProviderExtensions(StringBuilder sb)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Extension methods for TimeProvider to support delay and timeout operations.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class TimeProviderExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Creates a delay that respects the TimeProvider (works with FakeTimeProvider in tests).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static async Task Delay(this TimeProvider timeProvider, TimeSpan delay, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (delay <= TimeSpan.Zero) return;");
        sb.AppendLine("        ");
        sb.AppendLine("        var tcs = new TaskCompletionSource<bool>();");
        sb.AppendLine("        using var timer = timeProvider.CreateTimer(_ => tcs.TrySetResult(true), null, delay, Timeout.InfiniteTimeSpan);");
        sb.AppendLine("        using var registration = cancellationToken.Register(() => tcs.TrySetCanceled(cancellationToken));");
        sb.AppendLine("        await tcs.Task.ConfigureAwait(false);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Creates a CancellationTokenSource that cancels after the specified timeout using the TimeProvider.");
        sb.AppendLine("    /// The returned CTS is also linked to the parent token for graceful shutdown support.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static (CancellationTokenSource Cts, ITimer Timer) CreateTimeoutCts(this TimeProvider timeProvider, TimeSpan timeout, CancellationToken parentToken)");
        sb.AppendLine("    {");
        sb.AppendLine("        var cts = CancellationTokenSource.CreateLinkedTokenSource(parentToken);");
        sb.AppendLine("        var timer = timeProvider.CreateTimer(_ => cts.Cancel(), null, timeout, Timeout.InfiniteTimeSpan);");
        sb.AppendLine("        return (cts, timer);");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitWorkerExtension(StringBuilder sb, List<WorkerInvocationModel> workers)
    {
        // Build worker map first to determine signatures
        int caseNum = 1;
        var workerMap = new Dictionary<string, WorkerInvocationModel>();
        var signatureToMethod = new Dictionary<string, int>();

        foreach (var worker in workers)
        {
            // Build signature from worker parameters - strip global:: prefix and normalize spacing to match runtime format
            // Runtime uses FormatTypeName which joins generic args with "," (no space), so we must do the same
            var paramTypes = string.Join(",", worker.Parameters.Select(p => p.Type.Replace("global::", "").Replace(", ", ",")));
            var signature = $"{worker.Type}:{paramTypes}";

            if (!workerMap.ContainsKey(signature))
            {
                workerMap[signature] = worker;
                signatureToMethod[signature] = caseNum;
                caseNum++;
            }
        }

        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated class to wire up background workers using a module initializer.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class GeneratedBackgroundWorkerInitializer");
        sb.AppendLine("{");

        // Generate static dictionary for O(1) signature dispatch
        sb.AppendLine("    // O(1) signature dispatch dictionary - initialized once, used for all lookups");
        sb.AppendLine("    private static readonly System.Collections.Generic.Dictionary<string, Action<BackgroundWorkerExtensions.WorkerRegistration>> _workerInitializers = new()");
        sb.AppendLine("    {");
        foreach (var kvp in signatureToMethod)
        {
            sb.AppendLine($"        {{ \"{kvp.Key}\", InitializeWorker_{kvp.Value} }},");
        }
        sb.AppendLine("    };");
        sb.AppendLine();

        sb.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    internal static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Set the generated worker initializer");
        sb.AppendLine("        BackgroundWorkerExtensions._generatedWorkerInitializer = InitializeWorkers;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static void InitializeWorkers(IHost host)");
        sb.AppendLine("    {");
        sb.AppendLine("        var registrations = BackgroundWorkerExtensions._registrations");
        sb.AppendLine("            .Where(r => r.Host == host)");
        sb.AppendLine("            .ToList();");
        sb.AppendLine();
        sb.AppendLine("        // Initialize each worker using O(1) dictionary lookup");
        sb.AppendLine("        foreach (var registration in registrations)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_workerInitializers.TryGetValue(registration.Signature, out var initializer))");
        sb.AppendLine("            {");
        sb.AppendLine("                initializer(registration);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Emit worker initialization methods - one for each unique signature
        caseNum = 1;
        foreach (var kvp in workerMap)
        {
            EmitWorkerInitializer(sb, kvp.Value, caseNum);
            caseNum++;
        }

        sb.AppendLine("}");
    }

    private static void EmitWorkerInitializer(StringBuilder sb, WorkerInvocationModel worker, int workerNum)
    {
        sb.AppendLine($"    private static void InitializeWorker_{workerNum}(BackgroundWorkerExtensions.WorkerRegistration registration)");
        sb.AppendLine("    {");
        sb.AppendLine("        var host = registration.Host;");
        sb.AppendLine("        var lifetime = host.Services.GetRequiredService<IHostApplicationLifetime>();");
        sb.AppendLine();
        
        switch (worker.Type)
        {
            case WorkerType.Continuous:
                EmitContinuousWorkerInit(sb, worker);
                break;
            case WorkerType.Periodic:
                EmitPeriodicWorkerInit(sb, worker);
                break;
            case WorkerType.Cron:
                EmitCronWorkerInit(sb, worker);
                break;
        }
        
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void EmitContinuousWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        const string workerType = "continuous";

        // Validate dependencies at startup
        EmitDependencyValidation(sb, worker);

        // Setup variables
        sb.AppendLine("        // Start worker immediately - host has already started");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        var workerId = registration.Id.ToString();");
        sb.AppendLine("        var workerName = registration.DisplayName;");
        sb.AppendLine("        var timeout = registration.Timeout;");
        sb.AppendLine("        var retryMaxAttempts = registration.RetryMaxAttempts ?? 1;");
        sb.AppendLine("        var retryDelay = registration.RetryDelay ?? TimeSpan.Zero;");
        sb.AppendLine();
        sb.AppendLine("        // Cache service lookups at initialization (outside Task.Run)");
        sb.AppendLine("        var workerLogger = host.Services.GetService<ILoggerFactory>()?.CreateLogger($\"MinimalWorker.{workerName}\");");
        sb.AppendLine("        var timeProvider = host.Services.GetService<TimeProvider>() ?? TimeProvider.System;");
        sb.AppendLine();
        sb.AppendLine("        // Register worker for status tracking");
        sb.AppendLine($"        MinimalWorkerObservability.RegisterWorker(workerId, workerName, \"{workerType}\");");
        sb.AppendLine();
        sb.AppendLine("        // Log worker started");
        sb.AppendLine($"        if (workerLogger != null) WorkerLogMessages.WorkerStarted(workerLogger, workerName, \"{workerType}\", workerId, null);");
        sb.AppendLine();

        // Start Task.Run
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            using var scope = host.Services.CreateScope();");
        sb.AppendLine();

        // Resolve DI parameters
        EmitParameterResolution(sb, worker, "            ", "scope");

        sb.AppendLine();
        EmitTagListInit(sb, workerType, "            ");
        sb.AppendLine();
        EmitActivitySetup(sb, workerType, "            ");
        sb.AppendLine();
        sb.AppendLine("            var stopwatch = Stopwatch.StartNew();");
        sb.AppendLine("            Exception? lastException = null;");
        sb.AppendLine("            var succeeded = false;");
        sb.AppendLine();
        sb.AppendLine("            // Retry loop");
        sb.AppendLine("            for (var attempt = 1; attempt <= retryMaxAttempts && !token.IsCancellationRequested; attempt++)");
        sb.AppendLine("            {");
        sb.AppendLine("                CancellationTokenSource? timeoutCts = null;");
        sb.AppendLine("                ITimer? timeoutTimer = null;");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        sb.AppendLine("                    // Create execution token with optional timeout (uses TimeProvider for testability)");
        sb.AppendLine("                    if (timeout.HasValue)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        (timeoutCts, timeoutTimer) = timeProvider.CreateTimeoutCts(timeout.Value, token);");
        sb.AppendLine("                    }");
        sb.AppendLine("                    var executionToken = timeoutCts?.Token ?? token;");
        sb.AppendLine();

        // Note: For continuous workers, we need to substitute the token in the delegate parameters
        // We'll emit a local token variable that references executionToken
        EmitContinuousWorkerDelegateInvocation(sb, worker, delegateType, "                    ");

        // Record success
        EmitSuccessRecording(sb, "                    ");
        sb.AppendLine("                    succeeded = true;");
        sb.AppendLine("                    break; // Success - exit retry loop");

        sb.AppendLine("                }");
        sb.AppendLine("                catch (OperationCanceledException) when (token.IsCancellationRequested)");
        sb.AppendLine("                {");
        sb.AppendLine("                    // Graceful shutdown - exit without error, don't retry");
        sb.AppendLine("                    activity?.SetStatus(ActivityStatusCode.Ok);");
        sb.AppendLine("                    succeeded = true; // Mark as success to avoid error handling");
        sb.AppendLine("                    break;");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (OperationCanceledException) when (timeout.HasValue)");
        sb.AppendLine("                {");
        sb.AppendLine("                    // Timeout - don't retry timeouts");
        sb.AppendLine("                    lastException = new TimeoutException($\"Worker '{workerName}' execution timed out after {timeout.Value}.\");");
        sb.AppendLine("                    break;");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine("                    lastException = ex;");
        sb.AppendLine("                    if (attempt < retryMaxAttempts && retryDelay > TimeSpan.Zero && !token.IsCancellationRequested)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        // Wait before retry (uses TimeProvider for testability)");
        sb.AppendLine("                        try { await timeProvider.Delay(retryDelay, token); } catch (OperationCanceledException) { break; }");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("                finally");
        sb.AppendLine("                {");
        sb.AppendLine("                    timeoutTimer?.Dispose();");
        sb.AppendLine("                    timeoutCts?.Dispose();");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            // Handle failure after all retries exhausted");
        sb.AppendLine("            if (!succeeded && lastException != null)");
        sb.AppendLine("            {");
        sb.AppendLine("                activity?.SetStatus(ActivityStatusCode.Error, lastException.Message);");
        sb.AppendLine("                activity?.RecordException(lastException);");
        sb.AppendLine();
        sb.AppendLine("                var errorTags = tags;");
        sb.AppendLine("                errorTags.Add(\"exception.type\", lastException.GetType().FullName);");
        sb.AppendLine("                MinimalWorkerObservability.ErrorCounter.Add(1, errorTags);");
        sb.AppendLine("                MinimalWorkerObservability.RecordFailure(workerId);");
        sb.AppendLine();
        sb.AppendLine("                if (workerLogger != null) WorkerLogMessages.WorkerExecutionFailed(workerLogger, workerName, lastException);");
        sb.AppendLine();
        sb.AppendLine("                if (registration.OnError != null)");
        sb.AppendLine("                {");
        sb.AppendLine("                    registration.OnError(lastException);");
        sb.AppendLine("                }");
        sb.AppendLine("                else");
        sb.AppendLine("                {");
        sb.AppendLine("                    if (workerLogger != null) WorkerLogMessages.WorkerFatalError(workerLogger, workerName, lastException);");
        sb.AppendLine("                    BackgroundWorkerExtensions.TerminateOnFatalError(lastException);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        EmitDurationRecording(sb, "            ");
        sb.AppendLine("            // Deactivate worker when it completes");
        EmitWorkerDeactivation(sb, workerType, "            ");
        sb.AppendLine("        }, token);");
    }

    private static void EmitPeriodicWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        const string workerType = "periodic";

        // Validate dependencies at startup
        EmitDependencyValidation(sb, worker);

        // Setup variables
        sb.AppendLine("        var schedule = (TimeSpan)registration.Schedule!;");
        sb.AppendLine("        var workerId = registration.Id.ToString();");
        sb.AppendLine("        var workerName = registration.DisplayName;");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        var timeout = registration.Timeout;");
        sb.AppendLine("        var retryMaxAttempts = registration.RetryMaxAttempts ?? 1;");
        sb.AppendLine("        var retryDelay = registration.RetryDelay ?? TimeSpan.Zero;");
        sb.AppendLine();
        sb.AppendLine("        // Cache service lookups at initialization (outside Task.Run)");
        sb.AppendLine("        var workerLogger = host.Services.GetService<ILoggerFactory>()?.CreateLogger($\"MinimalWorker.{workerName}\");");
        sb.AppendLine("        var timeProvider = host.Services.GetService<TimeProvider>() ?? TimeProvider.System;");
        sb.AppendLine();
        sb.AppendLine("        // Register worker for status tracking");
        sb.AppendLine($"        MinimalWorkerObservability.RegisterWorker(workerId, workerName, \"{workerType}\");");
        sb.AppendLine();
        sb.AppendLine("        // Log worker started");
        sb.AppendLine($"        if (workerLogger != null) WorkerLogMessages.WorkerStartedWithSchedule(workerLogger, workerName, \"{workerType}\", workerId, schedule, null);");
        sb.AppendLine();

        // Start Task.Run
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            // Pre-allocate tags outside loop to avoid per-iteration allocation");
        EmitTagListInit(sb, workerType, "            ");
        sb.AppendLine("            var scheduleString = schedule.ToString();");
        sb.AppendLine();
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                using var timer = new PeriodicTimer(schedule, timeProvider);");
        sb.AppendLine("                while (await timer.WaitForNextTickAsync(token))");
        sb.AppendLine("                {");
        EmitActivitySetup(sb, workerType, "                    ", new[] { "activity?.SetTag(\"worker.schedule\", scheduleString);" });
        sb.AppendLine();
        sb.AppendLine("                    var stopwatch = Stopwatch.StartNew();");
        sb.AppendLine("                    Exception? lastException = null;");
        sb.AppendLine("                    var succeeded = false;");
        sb.AppendLine();
        sb.AppendLine("                    // Retry loop");
        sb.AppendLine("                    for (var attempt = 1; attempt <= retryMaxAttempts && !token.IsCancellationRequested; attempt++)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        CancellationTokenSource? timeoutCts = null;");
        sb.AppendLine("                        ITimer? timeoutTimer = null;");
        sb.AppendLine("                        try");
        sb.AppendLine("                        {");
        sb.AppendLine("                            using var scope = host.Services.CreateScope();");
        sb.AppendLine();
        sb.AppendLine("                            // Create execution token with optional timeout (uses TimeProvider for testability)");
        sb.AppendLine("                            if (timeout.HasValue)");
        sb.AppendLine("                            {");
        sb.AppendLine("                                (timeoutCts, timeoutTimer) = timeProvider.CreateTimeoutCts(timeout.Value, token);");
        sb.AppendLine("                            }");
        sb.AppendLine("                            var executionToken = timeoutCts?.Token ?? token;");
        sb.AppendLine();

        // Resolve DI parameters - use executionToken for CancellationToken
        EmitParameterResolutionWithExecutionToken(sb, worker, "                            ", "scope");

        sb.AppendLine();

        // Invoke the delegate
        EmitDelegateInvocation(sb, worker, delegateType, "                            ");

        // Record success
        EmitSuccessRecording(sb, "                            ");
        sb.AppendLine("                            succeeded = true;");
        sb.AppendLine("                            break; // Success - exit retry loop");

        sb.AppendLine("                        }");
        sb.AppendLine("                        catch (OperationCanceledException) when (token.IsCancellationRequested)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            // Graceful shutdown - exit without error, don't retry");
        sb.AppendLine("                            activity?.SetStatus(ActivityStatusCode.Ok);");
        sb.AppendLine("                            succeeded = true; // Mark as success to avoid error handling");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        }");
        sb.AppendLine("                        catch (OperationCanceledException) when (timeout.HasValue)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            // Timeout - don't retry timeouts");
        sb.AppendLine("                            lastException = new TimeoutException($\"Worker '{workerName}' execution timed out after {timeout.Value}.\");");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        }");
        sb.AppendLine("                        catch (Exception ex)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            lastException = ex;");
        sb.AppendLine("                            if (attempt < retryMaxAttempts && retryDelay > TimeSpan.Zero && !token.IsCancellationRequested)");
        sb.AppendLine("                            {");
        sb.AppendLine("                                // Wait before retry (uses TimeProvider for testability)");
        sb.AppendLine("                                try { await timeProvider.Delay(retryDelay, token); } catch (OperationCanceledException) { break; }");
        sb.AppendLine("                            }");
        sb.AppendLine("                        }");
        sb.AppendLine("                        finally");
        sb.AppendLine("                        {");
        sb.AppendLine("                            timeoutTimer?.Dispose();");
        sb.AppendLine("                            timeoutCts?.Dispose();");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine();
        sb.AppendLine("                    // Handle failure after all retries exhausted");
        sb.AppendLine("                    if (!succeeded && lastException != null)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Error, lastException.Message);");
        sb.AppendLine("                        activity?.RecordException(lastException);");
        sb.AppendLine();
        sb.AppendLine("                        var errorTags = tags;");
        sb.AppendLine("                        errorTags.Add(\"exception.type\", lastException.GetType().FullName);");
        sb.AppendLine("                        MinimalWorkerObservability.ErrorCounter.Add(1, errorTags);");
        sb.AppendLine("                        MinimalWorkerObservability.RecordFailure(workerId);");
        sb.AppendLine();
        sb.AppendLine("                        if (workerLogger != null) WorkerLogMessages.WorkerExecutionFailed(workerLogger, workerName, lastException);");
        sb.AppendLine();
        sb.AppendLine("                        if (registration.OnError != null)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            registration.OnError(lastException);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        else");
        sb.AppendLine("                        {");
        sb.AppendLine("                            if (workerLogger != null) WorkerLogMessages.WorkerFatalError(workerLogger, workerName, lastException);");
        sb.AppendLine("                            BackgroundWorkerExtensions.TerminateOnFatalError(lastException);");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine();
        sb.AppendLine("                    // Check for graceful shutdown after retry loop");
        sb.AppendLine("                    if (token.IsCancellationRequested) break;");
        sb.AppendLine();
        EmitDurationRecording(sb, "                    ");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (OperationCanceledException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Graceful shutdown - exit without error");
        sb.AppendLine("            }");
        sb.AppendLine("            finally");
        sb.AppendLine("            {");
        EmitWorkerDeactivation(sb, workerType, "                ");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static void EmitCronWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        const string workerType = "cron";

        // Validate dependencies at startup
        EmitDependencyValidation(sb, worker);

        // Setup variables
        sb.AppendLine("        var cronExpression = (string)registration.Schedule!;");
        sb.AppendLine("        var schedule = NCrontab.CrontabSchedule.Parse(cronExpression);");
        sb.AppendLine("        var workerId = registration.Id.ToString();");
        sb.AppendLine("        var workerName = registration.DisplayName;");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        var timeout = registration.Timeout;");
        sb.AppendLine("        var retryMaxAttempts = registration.RetryMaxAttempts ?? 1;");
        sb.AppendLine("        var retryDelay = registration.RetryDelay ?? TimeSpan.Zero;");
        sb.AppendLine();
        sb.AppendLine("        // Cache service lookups at initialization (outside Task.Run)");
        sb.AppendLine("        var workerLogger = host.Services.GetService<ILoggerFactory>()?.CreateLogger($\"MinimalWorker.{workerName}\");");
        sb.AppendLine("        var timeProvider = host.Services.GetService<TimeProvider>() ?? TimeProvider.System;");
        sb.AppendLine();
        sb.AppendLine("        // Register worker for status tracking");
        sb.AppendLine($"        MinimalWorkerObservability.RegisterWorker(workerId, workerName, \"{workerType}\");");
        sb.AppendLine();
        sb.AppendLine("        // Log worker started");
        sb.AppendLine($"        if (workerLogger != null) WorkerLogMessages.WorkerStartedWithCron(workerLogger, workerName, \"{workerType}\", workerId, cronExpression, null);");
        sb.AppendLine();

        // Start Task.Run
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            // Pre-allocate tags outside loop to avoid per-iteration allocation");
        EmitTagListInit(sb, workerType, "            ");
        sb.AppendLine();
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                while (!token.IsCancellationRequested)");
        sb.AppendLine("                {");
        sb.AppendLine("                    var now = timeProvider.GetUtcNow().DateTime;");
        sb.AppendLine("                    var nextRun = schedule.GetNextOccurrence(now);");
        sb.AppendLine("                    var delay = nextRun - now;");
        sb.AppendLine();
        sb.AppendLine("                    if (delay > TimeSpan.Zero)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        var tcs = new TaskCompletionSource<bool>();");
        sb.AppendLine("                        using var timer = timeProvider.CreateTimer(_ => tcs.TrySetResult(true), null, delay, Timeout.InfiniteTimeSpan);");
        sb.AppendLine("                        using var reg = token.Register(() => tcs.TrySetCanceled());");
        sb.AppendLine("                        try { await tcs.Task; } catch (OperationCanceledException) when (token.IsCancellationRequested) { break; }");
        sb.AppendLine("                    }");
        sb.AppendLine();
        EmitActivitySetup(sb, workerType, "                    ", new[]
        {
            "activity?.SetTag(\"cron.expression\", cronExpression);",
            "activity?.SetTag(\"cron.next_run\", nextRun.ToString(\"o\"));"
        });
        sb.AppendLine();
        sb.AppendLine("                    var stopwatch = Stopwatch.StartNew();");
        sb.AppendLine("                    Exception? lastException = null;");
        sb.AppendLine("                    var succeeded = false;");
        sb.AppendLine();
        sb.AppendLine("                    // Retry loop");
        sb.AppendLine("                    for (var attempt = 1; attempt <= retryMaxAttempts && !token.IsCancellationRequested; attempt++)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        CancellationTokenSource? timeoutCts = null;");
        sb.AppendLine("                        ITimer? timeoutTimer = null;");
        sb.AppendLine("                        try");
        sb.AppendLine("                        {");
        sb.AppendLine("                            using var scope = host.Services.CreateScope();");
        sb.AppendLine();
        sb.AppendLine("                            // Create execution token with optional timeout (uses TimeProvider for testability)");
        sb.AppendLine("                            if (timeout.HasValue)");
        sb.AppendLine("                            {");
        sb.AppendLine("                                (timeoutCts, timeoutTimer) = timeProvider.CreateTimeoutCts(timeout.Value, token);");
        sb.AppendLine("                            }");
        sb.AppendLine("                            var executionToken = timeoutCts?.Token ?? token;");
        sb.AppendLine();

        // Resolve DI parameters - use executionToken for CancellationToken
        EmitParameterResolutionWithExecutionToken(sb, worker, "                            ", "scope");

        sb.AppendLine();

        // Invoke the delegate
        EmitDelegateInvocation(sb, worker, delegateType, "                            ");

        // Record success
        EmitSuccessRecording(sb, "                            ");
        sb.AppendLine("                            succeeded = true;");
        sb.AppendLine("                            break; // Success - exit retry loop");

        sb.AppendLine("                        }");
        sb.AppendLine("                        catch (OperationCanceledException) when (token.IsCancellationRequested)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            // Graceful shutdown - exit without error, don't retry");
        sb.AppendLine("                            activity?.SetStatus(ActivityStatusCode.Ok);");
        sb.AppendLine("                            succeeded = true; // Mark as success to avoid error handling");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        }");
        sb.AppendLine("                        catch (OperationCanceledException) when (timeout.HasValue)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            // Timeout - don't retry timeouts");
        sb.AppendLine("                            lastException = new TimeoutException($\"Worker '{workerName}' execution timed out after {timeout.Value}.\");");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        }");
        sb.AppendLine("                        catch (Exception ex)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            lastException = ex;");
        sb.AppendLine("                            if (attempt < retryMaxAttempts && retryDelay > TimeSpan.Zero && !token.IsCancellationRequested)");
        sb.AppendLine("                            {");
        sb.AppendLine("                                // Wait before retry (uses TimeProvider for testability)");
        sb.AppendLine("                                try { await timeProvider.Delay(retryDelay, token); } catch (OperationCanceledException) { break; }");
        sb.AppendLine("                            }");
        sb.AppendLine("                        }");
        sb.AppendLine("                        finally");
        sb.AppendLine("                        {");
        sb.AppendLine("                            timeoutTimer?.Dispose();");
        sb.AppendLine("                            timeoutCts?.Dispose();");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine();
        sb.AppendLine("                    // Handle failure after all retries exhausted");
        sb.AppendLine("                    if (!succeeded && lastException != null)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Error, lastException.Message);");
        sb.AppendLine("                        activity?.RecordException(lastException);");
        sb.AppendLine();
        sb.AppendLine("                        var errorTags = tags;");
        sb.AppendLine("                        errorTags.Add(\"exception.type\", lastException.GetType().FullName);");
        sb.AppendLine("                        MinimalWorkerObservability.ErrorCounter.Add(1, errorTags);");
        sb.AppendLine("                        MinimalWorkerObservability.RecordFailure(workerId);");
        sb.AppendLine();
        sb.AppendLine("                        if (workerLogger != null) WorkerLogMessages.WorkerExecutionFailed(workerLogger, workerName, lastException);");
        sb.AppendLine();
        sb.AppendLine("                        if (registration.OnError != null)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            registration.OnError(lastException);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        else");
        sb.AppendLine("                        {");
        sb.AppendLine("                            if (workerLogger != null) WorkerLogMessages.WorkerFatalError(workerLogger, workerName, lastException);");
        sb.AppendLine("                            BackgroundWorkerExtensions.TerminateOnFatalError(lastException);");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine();
        sb.AppendLine("                    // Check for graceful shutdown after retry loop");
        sb.AppendLine("                    if (token.IsCancellationRequested) break;");
        sb.AppendLine();
        EmitDurationRecording(sb, "                    ");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (OperationCanceledException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Graceful shutdown - exit without error");
        sb.AppendLine("            }");
        sb.AppendLine("            finally");
        sb.AppendLine("            {");
        EmitWorkerDeactivation(sb, workerType, "                ");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static string GetDelegateType(WorkerInvocationModel worker)
    {
        var paramTypes = string.Join(", ", worker.Parameters.Select(p => p.Type));

        // For synchronous delegates (void return), use Action
        if (!worker.IsAsync)
        {
            if (string.IsNullOrEmpty(paramTypes))
            {
                return "Action";
            }
            return $"Action<{paramTypes}>";
        }

        // For asynchronous delegates, use Func with Task return
        if (string.IsNullOrEmpty(paramTypes))
        {
            return $"Func<{worker.ReturnType}>";
        }
        return $"Func<{paramTypes}, {worker.ReturnType}>";
    }

    #region Helper Methods for Code Emission

    /// <summary>
    /// Emits dependency validation code that checks all DI dependencies can be resolved at startup.
    /// </summary>
    private static void EmitDependencyValidation(StringBuilder sb, WorkerInvocationModel worker)
    {
        sb.AppendLine("        // Validate dependencies exist before starting worker (fail-fast)");
        sb.AppendLine("        using (var validationScope = host.Services.CreateScope())");
        sb.AppendLine("        {");

        foreach (var param in worker.Parameters)
        {
            if (!param.IsCancellationToken)
            {
                sb.AppendLine($"            _ = validationScope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    /// <summary>
    /// Emits DI parameter resolution code.
    /// </summary>
    private static void EmitParameterResolution(StringBuilder sb, WorkerInvocationModel worker, string indent, string scopeVar)
    {
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"{indent}var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"{indent}var {param.Name} = {scopeVar}.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
    }

    /// <summary>
    /// Emits DI parameter resolution code using executionToken for CancellationToken parameters.
    /// Used when timeout support is needed.
    /// </summary>
    private static void EmitParameterResolutionWithExecutionToken(StringBuilder sb, WorkerInvocationModel worker, string indent, string scopeVar)
    {
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"{indent}var {param.Name} = executionToken;");
            }
            else
            {
                sb.AppendLine($"{indent}var {param.Name} = {scopeVar}.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
    }

    /// <summary>
    /// Emits delegate invocation code.
    /// </summary>
    private static void EmitDelegateInvocation(StringBuilder sb, WorkerInvocationModel worker, string delegateType, string indent)
    {
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));

        if (worker.IsAsync)
        {
            sb.AppendLine($"{indent}await (({delegateType})registration.Action)({paramNames});");
        }
        else
        {
            sb.AppendLine($"{indent}(({delegateType})registration.Action)({paramNames});");
        }
    }

    /// <summary>
    /// Emits delegate invocation code for continuous workers, using executionToken for CancellationToken parameters.
    /// </summary>
    private static void EmitContinuousWorkerDelegateInvocation(StringBuilder sb, WorkerInvocationModel worker, string delegateType, string indent)
    {
        // For continuous workers, parameters are resolved outside the retry loop,
        // but we need to pass executionToken instead of the resolved token parameter
        var paramNames = string.Join(", ", worker.Parameters.Select(p =>
            p.IsCancellationToken ? "executionToken" : p.Name));

        if (worker.IsAsync)
        {
            sb.AppendLine($"{indent}await (({delegateType})registration.Action)({paramNames});");
        }
        else
        {
            sb.AppendLine($"{indent}(({delegateType})registration.Action)({paramNames});");
        }
    }

    /// <summary>
    /// Emits success recording code (execution counter, success tracking, activity status).
    /// </summary>
    private static void EmitSuccessRecording(StringBuilder sb, string indent)
    {
        sb.AppendLine();
        sb.AppendLine($"{indent}MinimalWorkerObservability.ExecutionCounter.Add(1, tags);");
        sb.AppendLine($"{indent}MinimalWorkerObservability.RecordSuccess(workerId);");
        sb.AppendLine($"{indent}activity?.SetStatus(ActivityStatusCode.Ok);");
    }

    /// <summary>
    /// Emits error handling code for the catch block.
    /// </summary>
    private static void EmitErrorHandling(StringBuilder sb, string indent)
    {
        sb.AppendLine($"{indent}activity?.SetStatus(ActivityStatusCode.Error, ex.Message);");
        sb.AppendLine($"{indent}activity?.RecordException(ex);");
        sb.AppendLine();
        sb.AppendLine($"{indent}// Copy base tags struct and add exception type (avoids full allocation in catch)");
        sb.AppendLine($"{indent}var errorTags = tags;");
        sb.AppendLine($"{indent}errorTags.Add(\"exception.type\", ex.GetType().FullName);");
        sb.AppendLine($"{indent}MinimalWorkerObservability.ErrorCounter.Add(1, errorTags);");
        sb.AppendLine($"{indent}MinimalWorkerObservability.RecordFailure(workerId);");
        sb.AppendLine();
        sb.AppendLine($"{indent}// Log error");
        sb.AppendLine($"{indent}if (workerLogger != null) WorkerLogMessages.WorkerExecutionFailed(workerLogger, workerName, ex);");
        sb.AppendLine();
        sb.AppendLine($"{indent}if (registration.OnError != null)");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    registration.OnError(ex);");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine($"{indent}else");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    // No error handler provided - crash the app (fail-fast)");
        sb.AppendLine($"{indent}    if (workerLogger != null) WorkerLogMessages.WorkerFatalError(workerLogger, workerName, ex);");
        sb.AppendLine($"{indent}    ");
        sb.AppendLine($"{indent}    // Terminate the application immediately");
        sb.AppendLine($"{indent}    BackgroundWorkerExtensions.TerminateOnFatalError(ex);");
        sb.AppendLine($"{indent}}}");
    }

    /// <summary>
    /// Emits duration recording code for the finally block.
    /// </summary>
    private static void EmitDurationRecording(StringBuilder sb, string indent)
    {
        sb.AppendLine($"{indent}stopwatch.Stop();");
        sb.AppendLine($"{indent}MinimalWorkerObservability.DurationHistogram.Record(stopwatch.Elapsed.TotalMilliseconds, tags);");
    }

    /// <summary>
    /// Emits worker deactivation and stop logging code.
    /// </summary>
    private static void EmitWorkerDeactivation(StringBuilder sb, string workerType, string indent)
    {
        sb.AppendLine($"{indent}// Deactivate worker when it stops");
        sb.AppendLine($"{indent}MinimalWorkerObservability.DeactivateWorker(workerId);");
        sb.AppendLine($"{indent}if (workerLogger != null) WorkerLogMessages.WorkerStopped(workerLogger, workerName, \"{workerType}\", workerId, null);");
    }

    /// <summary>
    /// Emits activity setup code with common tags.
    /// </summary>
    private static void EmitActivitySetup(StringBuilder sb, string workerType, string indent, string[]? extraTags = null)
    {
        sb.AppendLine($"{indent}using var activity = MinimalWorkerObservability.ActivitySource.StartActivity(\"worker.execute\");");
        sb.AppendLine($"{indent}activity?.SetTag(\"worker.id\", workerId);");
        sb.AppendLine($"{indent}activity?.SetTag(\"worker.name\", workerName);");
        sb.AppendLine($"{indent}activity?.SetTag(\"worker.type\", \"{workerType}\");");

        if (extraTags != null)
        {
            foreach (var tag in extraTags)
            {
                sb.AppendLine($"{indent}{tag}");
            }
        }
    }

    /// <summary>
    /// Emits TagList initialization for metrics.
    /// </summary>
    private static void EmitTagListInit(StringBuilder sb, string workerType, string indent)
    {
        sb.AppendLine($"{indent}var tags = new TagList");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    {{ \"worker.id\", workerId }},");
        sb.AppendLine($"{indent}    {{ \"worker.name\", workerName }},");
        sb.AppendLine($"{indent}    {{ \"worker.type\", \"{workerType}\" }}");
        sb.AppendLine($"{indent}}};");
    }

    #endregion
}
