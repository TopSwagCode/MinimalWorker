using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MinimalWorker.Generators;

/// <summary>
/// Emits strongly-typed, AOT-compatible code for background workers.
/// No reflection - generates direct method calls with DI resolution.
/// </summary>
internal static class WorkerEmitter
{
    public static string EmitSource(List<WorkerInvocationModel> workers)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// MinimalWorker Source Generator");
        sb.AppendLine("// AOT-compatible background worker registration");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Diagnostics;");
        sb.AppendLine("using System.Diagnostics.Metrics;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.Hosting;");
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.AppendLine();
        sb.AppendLine("namespace MinimalWorker;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Extension methods for Activity to support exception recording.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class ActivityExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Records an exception on the activity following OpenTelemetry semantic conventions.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static void RecordException(this Activity? activity, Exception exception)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (activity == null) return;");
        sb.AppendLine();
        sb.AppendLine("        activity.SetTag(\"exception.type\", exception.GetType().FullName);");
        sb.AppendLine("        activity.SetTag(\"exception.message\", exception.Message);");
        sb.AppendLine("        activity.SetTag(\"exception.stacktrace\", exception.ToString());");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Observability instruments for MinimalWorker.");
        sb.AppendLine("/// ActivitySource and Meter are automatically consumed by OpenTelemetry when configured.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class MinimalWorkerObservability");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// ActivitySource for distributed tracing.");
        sb.AppendLine("    /// Configure with: tracerProvider.AddSource(\"MinimalWorker\")");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly ActivitySource ActivitySource = new(\"MinimalWorker\", \"3.0.0\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Meter for metrics collection.");
        sb.AppendLine("    /// Configure with: meterProvider.AddMeter(\"MinimalWorker\")");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Meter Meter = new(\"MinimalWorker\", \"3.0.0\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Counter for total worker executions.");
        sb.AppendLine("    /// Dimensions: worker.id, worker.type");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Counter<long> ExecutionCounter = Meter.CreateCounter<long>(");
        sb.AppendLine("        \"minimal_worker.executions\",");
        sb.AppendLine("        unit: \"{execution}\",");
        sb.AppendLine("        description: \"Total number of worker executions\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Counter for total worker errors.");
        sb.AppendLine("    /// Dimensions: worker.id, worker.type, error.type");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Counter<long> ErrorCounter = Meter.CreateCounter<long>(");
        sb.AppendLine("        \"minimal_worker.errors\",");
        sb.AppendLine("        unit: \"{error}\",");
        sb.AppendLine("        description: \"Total number of worker errors\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Histogram for worker execution duration.");
        sb.AppendLine("    /// Dimensions: worker.id, worker.type");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Histogram<double> DurationHistogram = Meter.CreateHistogram<double>(");
        sb.AppendLine("        \"minimal_worker.duration\",");
        sb.AppendLine("        unit: \"ms\",");
        sb.AppendLine("        description: \"Duration of worker executions in milliseconds\");");
        sb.AppendLine("}");
        sb.AppendLine();
        
        // Emit the extension method that wires up all workers
        EmitWorkerExtension(sb, workers);
        
        return sb.ToString();
    }

    private static void EmitWorkerExtension(StringBuilder sb, List<WorkerInvocationModel> workers)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated class to wire up background workers using a module initializer.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class GeneratedBackgroundWorkerInitializer");
        sb.AppendLine("{");
        sb.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    internal static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Set the generated worker initializer");
        sb.AppendLine("        BackgroundWorkerExtensions._generatedWorkerInitializer = InitializeWorkers;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static void InitializeWorkers(IHost host)");
        sb.AppendLine("    {");
        sb.AppendLine("        var registrations = BackgroundWorkerExtensions._registrations");
        sb.AppendLine("            .Where(r => r.Host == host)");
        sb.AppendLine("            .ToList();");
        sb.AppendLine();
        sb.AppendLine("        // Initialize each worker based on its parameter signature");
        sb.AppendLine("        foreach (var registration in registrations)");
        sb.AppendLine("        {");
        
        // Generate a switch statement to match workers by their unique signature
        sb.AppendLine("            switch (registration.Signature)");
        sb.AppendLine("            {");
        
        // Create a case for each unique worker signature
        int caseNum = 1;
        var workerMap = new Dictionary<string, WorkerInvocationModel>();
        foreach (var worker in workers)
        {
            // Build signature from worker parameters - strip global:: prefix to match runtime format
            var paramTypes = string.Join(",", worker.Parameters.Select(p => p.Type.Replace("global::", "")));
            var signature = $"{worker.Type}:{paramTypes}";
            
            if (!workerMap.ContainsKey(signature))
            {
                workerMap[signature] = worker;
                sb.AppendLine($"                case \"{signature}\":");
                sb.AppendLine($"                    InitializeWorker_{caseNum}(registration);");
                sb.AppendLine("                    break;");
                caseNum++;
            }
        }
        
        sb.AppendLine("                default:");
        sb.AppendLine("                    // No matching worker initializer - this shouldn't happen");
        sb.AppendLine("                    break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // Emit worker initialization methods - one for each unique signature
        caseNum = 1;
        foreach (var kvp in workerMap)
        {
            EmitWorkerInitializer(sb, kvp.Value, caseNum);
            caseNum++;
        }
        
        sb.AppendLine("}");
    }

    private static void EmitWorkerInitializer(StringBuilder sb, WorkerInvocationModel worker, int workerNum)
    {
        sb.AppendLine($"    private static void InitializeWorker_{workerNum}(BackgroundWorkerExtensions.WorkerRegistration registration)");
        sb.AppendLine("    {");
        sb.AppendLine("        var host = registration.Host;");
        sb.AppendLine("        var lifetime = host.Services.GetRequiredService<IHostApplicationLifetime>();");
        sb.AppendLine();
        
        switch (worker.Type)
        {
            case WorkerType.Continuous:
                EmitContinuousWorkerInit(sb, worker);
                break;
            case WorkerType.Periodic:
                EmitPeriodicWorkerInit(sb, worker);
                break;
            case WorkerType.Cron:
                EmitCronWorkerInit(sb, worker);
                break;
        }
        
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void EmitContinuousWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        // Validate dependencies exist before starting worker (fail-fast)");
        sb.AppendLine("        using (var validationScope = host.Services.CreateScope())");
        sb.AppendLine("        {");
        
        // Validate all dependencies can be resolved
        foreach (var param in worker.Parameters)
        {
            if (!param.IsCancellationToken)
            {
                sb.AppendLine($"            _ = validationScope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Start worker immediately - host has already started");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"            var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"            var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        sb.AppendLine("            var workerId = registration.Id.ToString();");
        sb.AppendLine("            var iteration = 0L;");
        sb.AppendLine();
        sb.AppendLine("            while (!token.IsCancellationRequested)");
        sb.AppendLine("            {");
        sb.AppendLine("                iteration++;");
        sb.AppendLine("                using var activity = MinimalWorkerObservability.ActivitySource.StartActivity(\"worker.execute\");");
        sb.AppendLine("                activity?.SetTag(\"worker.id\", workerId);");
        sb.AppendLine("                activity?.SetTag(\"worker.type\", \"continuous\");");
        sb.AppendLine("                activity?.SetTag(\"worker.iteration\", iteration);");
        sb.AppendLine();
        sb.AppendLine("                var stopwatch = Stopwatch.StartNew();");
        sb.AppendLine("                var tags = new TagList");
        sb.AppendLine("                {");
        sb.AppendLine("                    { \"worker.id\", workerId },");
        sb.AppendLine("                    { \"worker.type\", \"continuous\" }");
        sb.AppendLine("                };");
        sb.AppendLine();
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                    await (({delegateType})registration.Action)({paramNames});");
        sb.AppendLine();
        sb.AppendLine("                    MinimalWorkerObservability.ExecutionCounter.Add(1, tags);");
        sb.AppendLine("                    activity?.SetStatus(ActivityStatusCode.Ok);");
        
        sb.AppendLine("                }");
        sb.AppendLine("                catch (OperationCanceledException)");
        sb.AppendLine("                {");
        sb.AppendLine("                    // Graceful shutdown - exit without error");
        sb.AppendLine("                    activity?.SetStatus(ActivityStatusCode.Ok);");
        sb.AppendLine("                    break;");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine("                    activity?.SetStatus(ActivityStatusCode.Error, ex.Message);");
        sb.AppendLine("                    activity?.RecordException(ex);");
        sb.AppendLine();
        sb.AppendLine("                    var errorTags = new TagList");
        sb.AppendLine("                    {");
        sb.AppendLine("                        { \"worker.id\", workerId },");
        sb.AppendLine("                        { \"worker.type\", \"continuous\" },");
        sb.AppendLine("                        { \"error.type\", ex.GetType().Name }");
        sb.AppendLine("                    };");
        sb.AppendLine("                    MinimalWorkerObservability.ErrorCounter.Add(1, errorTags);");
        sb.AppendLine();
        sb.AppendLine("                    if (registration.OnError != null)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        registration.OnError(ex);");
        sb.AppendLine("                    }");
        sb.AppendLine("                    else");
        sb.AppendLine("                    {");
        sb.AppendLine("                        // No error handler provided - log and crash the app (fail-fast)");
        sb.AppendLine("                        var loggerFactory = scope.ServiceProvider.GetService<ILoggerFactory>();");
        sb.AppendLine("                        var logger = loggerFactory?.CreateLogger(\"MinimalWorker\");");
        sb.AppendLine("                        ");
        sb.AppendLine("                        if (logger != null)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            logger.LogCritical(ex, \"FATAL: Unhandled exception in background worker. Application will terminate.\");");
        sb.AppendLine("                        }");
        sb.AppendLine("                        else");
        sb.AppendLine("                        {");
        sb.AppendLine("                            System.Console.Error.WriteLine($\"FATAL: Unhandled exception in background worker. Application will terminate.\");");
        sb.AppendLine("                            System.Console.Error.WriteLine($\"Exception: {ex}\");");
        sb.AppendLine("                        }");
        sb.AppendLine("                        ");
        sb.AppendLine("                        // Terminate the application immediately");
        sb.AppendLine("                        BackgroundWorkerExtensions.TerminateOnFatalError(ex);");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("                finally");
        sb.AppendLine("                {");
        sb.AppendLine("                    stopwatch.Stop();");
        sb.AppendLine("                    MinimalWorkerObservability.DurationHistogram.Record(stopwatch.Elapsed.TotalMilliseconds, tags);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static void EmitPeriodicWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        // Validate dependencies exist before starting worker (fail-fast)");
        sb.AppendLine("        using (var validationScope = host.Services.CreateScope())");
        sb.AppendLine("        {");
        
        // Validate all dependencies can be resolved
        foreach (var param in worker.Parameters)
        {
            if (!param.IsCancellationToken)
            {
                sb.AppendLine($"            _ = validationScope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        var schedule = (TimeSpan)registration.Schedule!;");
        sb.AppendLine("        var workerId = registration.Id.ToString();");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                var timer = new PeriodicTimer(schedule);");
        sb.AppendLine("                while (await timer.WaitForNextTickAsync(token))");
        sb.AppendLine("                {");
        sb.AppendLine("                    using var activity = MinimalWorkerObservability.ActivitySource.StartActivity(\"worker.execute\");");
        sb.AppendLine("                    activity?.SetTag(\"worker.id\", workerId);");
        sb.AppendLine("                    activity?.SetTag(\"worker.type\", \"periodic\");");
        sb.AppendLine("                    activity?.SetTag(\"worker.schedule\", schedule.ToString());");
        sb.AppendLine();
        sb.AppendLine("                    var stopwatch = Stopwatch.StartNew();");
        sb.AppendLine("                    var tags = new TagList");
        sb.AppendLine("                    {");
        sb.AppendLine("                        { \"worker.id\", workerId },");
        sb.AppendLine("                        { \"worker.type\", \"periodic\" }");
        sb.AppendLine("                    };");
        sb.AppendLine();
        sb.AppendLine("                    try");
        sb.AppendLine("                    {");
        sb.AppendLine("                        using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"                        var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"                        var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                        await (({delegateType})registration.Action)({paramNames});");
        sb.AppendLine();
        sb.AppendLine("                        MinimalWorkerObservability.ExecutionCounter.Add(1, tags);");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Ok);");
        
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (OperationCanceledException)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        // Graceful shutdown - exit without error");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Ok);");
        sb.AppendLine("                        break;");
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (Exception ex)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Error, ex.Message);");
        sb.AppendLine("                        activity?.RecordException(ex);");
        sb.AppendLine();
        sb.AppendLine("                        var errorTags = new TagList");
        sb.AppendLine("                        {");
        sb.AppendLine("                            { \"worker.id\", workerId },");
        sb.AppendLine("                            { \"worker.type\", \"periodic\" },");
        sb.AppendLine("                            { \"error.type\", ex.GetType().Name }");
        sb.AppendLine("                        };");
        sb.AppendLine("                        MinimalWorkerObservability.ErrorCounter.Add(1, errorTags);");
        sb.AppendLine();
        sb.AppendLine("                        if (registration.OnError != null)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            registration.OnError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        else");
        sb.AppendLine("                        {");
        sb.AppendLine("                            // No error handler provided - log and crash the app (fail-fast)");
        sb.AppendLine("                            using var errorScope = host.Services.CreateScope();");
        sb.AppendLine("                            var loggerFactory = errorScope.ServiceProvider.GetService<ILoggerFactory>();");
        sb.AppendLine("                            var logger = loggerFactory?.CreateLogger(\"MinimalWorker\");");
        sb.AppendLine("                            ");
        sb.AppendLine("                            if (logger != null)");
        sb.AppendLine("                            {");
        sb.AppendLine("                                logger.LogCritical(ex, \"FATAL: Unhandled exception in background worker. Application will terminate.\");");
        sb.AppendLine("                            }");
        sb.AppendLine("                            else");
        sb.AppendLine("                            {");
        sb.AppendLine("                                System.Console.Error.WriteLine($\"FATAL: Unhandled exception in background worker. Application will terminate.\");");
        sb.AppendLine("                                System.Console.Error.WriteLine($\"Exception: {ex}\");");
        sb.AppendLine("                            }");
        sb.AppendLine("                            ");
        sb.AppendLine("                            // Terminate the application immediately");
        sb.AppendLine("                            BackgroundWorkerExtensions.TerminateOnFatalError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine("                    finally");
        sb.AppendLine("                    {");
        sb.AppendLine("                        stopwatch.Stop();");
        sb.AppendLine("                        MinimalWorkerObservability.DurationHistogram.Record(stopwatch.Elapsed.TotalMilliseconds, tags);");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (OperationCanceledException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Graceful shutdown - exit without error");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static void EmitCronWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        // Validate dependencies exist before starting worker (fail-fast)");
        sb.AppendLine("        using (var validationScope = host.Services.CreateScope())");
        sb.AppendLine("        {");
        
        // Validate all dependencies can be resolved
        foreach (var param in worker.Parameters)
        {
            if (!param.IsCancellationToken)
            {
                sb.AppendLine($"            _ = validationScope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        var cronExpression = (string)registration.Schedule!;");
        sb.AppendLine("        var schedule = NCrontab.CrontabSchedule.Parse(cronExpression);");
        sb.AppendLine("        var workerId = registration.Id.ToString();");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                while (!token.IsCancellationRequested)");
        sb.AppendLine("                {");
        sb.AppendLine("                    var nextRun = schedule.GetNextOccurrence(DateTime.UtcNow);");
        sb.AppendLine("                    var delay = nextRun - DateTime.UtcNow;");
        sb.AppendLine();
        sb.AppendLine("                    if (delay > TimeSpan.Zero)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        try");
        sb.AppendLine("                        {");
        sb.AppendLine("                            await Task.Delay(delay, token);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        catch (OperationCanceledException)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine();
        sb.AppendLine("                    using var activity = MinimalWorkerObservability.ActivitySource.StartActivity(\"worker.execute\");");
        sb.AppendLine("                    activity?.SetTag(\"worker.id\", workerId);");
        sb.AppendLine("                    activity?.SetTag(\"worker.type\", \"cron\");");
        sb.AppendLine("                    activity?.SetTag(\"cron.expression\", cronExpression);");
        sb.AppendLine("                    activity?.SetTag(\"cron.next_run\", nextRun.ToString(\"o\"));");
        sb.AppendLine();
        sb.AppendLine("                    var stopwatch = Stopwatch.StartNew();");
        sb.AppendLine("                    var tags = new TagList");
        sb.AppendLine("                    {");
        sb.AppendLine("                        { \"worker.id\", workerId },");
        sb.AppendLine("                        { \"worker.type\", \"cron\" }");
        sb.AppendLine("                    };");
        sb.AppendLine();
        sb.AppendLine("                    try");
        sb.AppendLine("                    {");
        sb.AppendLine("                        using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"                        var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"                        var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                        await (({delegateType})registration.Action)({paramNames});");
        sb.AppendLine();
        sb.AppendLine("                        MinimalWorkerObservability.ExecutionCounter.Add(1, tags);");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Ok);");
        
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (OperationCanceledException)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        // Graceful shutdown - exit without error");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Ok);");
        sb.AppendLine("                        break;");
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (Exception ex)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Error, ex.Message);");
        sb.AppendLine("                        activity?.RecordException(ex);");
        sb.AppendLine();
        sb.AppendLine("                        var errorTags = new TagList");
        sb.AppendLine("                        {");
        sb.AppendLine("                            { \"worker.id\", workerId },");
        sb.AppendLine("                            { \"worker.type\", \"cron\" },");
        sb.AppendLine("                            { \"error.type\", ex.GetType().Name }");
        sb.AppendLine("                        };");
        sb.AppendLine("                        MinimalWorkerObservability.ErrorCounter.Add(1, errorTags);");
        sb.AppendLine();
        sb.AppendLine("                        if (registration.OnError != null)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            registration.OnError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        else");
        sb.AppendLine("                        {");
        sb.AppendLine("                            // No error handler provided - log and crash the app (fail-fast)");
        sb.AppendLine("                            using var errorScope = host.Services.CreateScope();");
        sb.AppendLine("                            var loggerFactory = errorScope.ServiceProvider.GetService<ILoggerFactory>();");
        sb.AppendLine("                            var logger = loggerFactory?.CreateLogger(\"MinimalWorker\");");
        sb.AppendLine("                            ");
        sb.AppendLine("                            if (logger != null)");
        sb.AppendLine("                            {");
        sb.AppendLine("                                logger.LogCritical(ex, \"FATAL: Unhandled exception in background worker. Application will terminate.\");");
        sb.AppendLine("                            }");
        sb.AppendLine("                            else");
        sb.AppendLine("                            {");
        sb.AppendLine("                                System.Console.Error.WriteLine($\"FATAL: Unhandled exception in background worker. Application will terminate.\");");
        sb.AppendLine("                                System.Console.Error.WriteLine($\"Exception: {ex}\");");
        sb.AppendLine("                            }");
        sb.AppendLine("                            ");
        sb.AppendLine("                            // Terminate the application immediately");
        sb.AppendLine("                            BackgroundWorkerExtensions.TerminateOnFatalError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine("                    finally");
        sb.AppendLine("                    {");
        sb.AppendLine("                        stopwatch.Stop();");
        sb.AppendLine("                        MinimalWorkerObservability.DurationHistogram.Record(stopwatch.Elapsed.TotalMilliseconds, tags);");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (OperationCanceledException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Graceful shutdown - exit without error");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static string GetDelegateType(WorkerInvocationModel worker)
    {
        var paramTypes = string.Join(", ", worker.Parameters.Select(p => p.Type));
        if (string.IsNullOrEmpty(paramTypes))
        {
            return $"Func<{worker.ReturnType}>";
        }
        return $"Func<{paramTypes}, {worker.ReturnType}>";
    }
}
