using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MinimalWorker.Generators;

/// <summary>
/// Emits strongly-typed, AOT-compatible code for background workers.
/// No reflection - generates direct method calls with DI resolution.
/// </summary>
internal static class WorkerEmitter
{
    public static string EmitSource(List<WorkerInvocationModel> workers)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// MinimalWorker Source Generator");
        sb.AppendLine("// AOT-compatible background worker registration");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.Hosting;");
        sb.AppendLine();
        sb.AppendLine("namespace MinimalWorker;");
        sb.AppendLine();
        
        // Emit the extension method that wires up all workers
        EmitWorkerExtension(sb, workers);
        
        return sb.ToString();
    }

    private static void EmitWorkerExtension(StringBuilder sb, List<WorkerInvocationModel> workers)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated class to wire up background workers using a module initializer.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class GeneratedBackgroundWorkerInitializer");
        sb.AppendLine("{");
        sb.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    internal static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Set the generated worker initializer");
        sb.AppendLine("        BackgroundWorkerExtensions._generatedWorkerInitializer = InitializeWorkers;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static void InitializeWorkers(IHost host)");
        sb.AppendLine("    {");
        sb.AppendLine("        var registrations = BackgroundWorkerExtensions._registrations");
        sb.AppendLine("            .Where(r => r.Host == host)");
        sb.AppendLine("            .ToList();");
        sb.AppendLine();
        sb.AppendLine("        // Initialize each worker based on its parameter count and type");
        sb.AppendLine("        foreach (var registration in registrations)");
        sb.AppendLine("        {");
        
        // Generate a switch statement to match workers by parameter count and type
        sb.AppendLine("            var key = (registration.ParameterCount, registration.Type);");
        sb.AppendLine("            switch (key)");
        sb.AppendLine("            {");
        
        // Group workers by (ParameterCount, Type) and emit cases
        var grouped = workers.GroupBy(w => (w.Parameters.Count, w.Type));
        int caseNum = 1;
        foreach (var group in grouped)
        {
            var (paramCount, workerType) = group.Key;
            var firstWorker = group.First();
            sb.AppendLine($"                case ({paramCount}, BackgroundWorkerExtensions.WorkerType.{workerType}):");
            sb.AppendLine($"                    InitializeWorker_{caseNum}(registration);");
            sb.AppendLine("                    break;");
            caseNum++;
        }
        
        sb.AppendLine("                default:");
        sb.AppendLine("                    // No matching worker initializer - this shouldn't happen");
        sb.AppendLine("                    break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // Emit worker initialization methods - one for each unique (ParameterCount, Type) combination
        caseNum = 1;
        foreach (var group in grouped)
        {
            EmitWorkerInitializer(sb, group.First(), caseNum);
            caseNum++;
        }
        
        sb.AppendLine("}");
    }

    private static void EmitWorkerInitializer(StringBuilder sb, WorkerInvocationModel worker, int workerNum)
    {
        sb.AppendLine($"    private static void InitializeWorker_{workerNum}(BackgroundWorkerExtensions.WorkerRegistration registration)");
        sb.AppendLine("    {");
        sb.AppendLine("        var host = registration.Host;");
        sb.AppendLine("        var lifetime = host.Services.GetRequiredService<IHostApplicationLifetime>();");
        sb.AppendLine();
        
        switch (worker.Type)
        {
            case WorkerType.Continuous:
                EmitContinuousWorkerInit(sb, worker);
                break;
            case WorkerType.Periodic:
                EmitPeriodicWorkerInit(sb, worker);
                break;
            case WorkerType.Cron:
                EmitCronWorkerInit(sb, worker);
                break;
        }
        
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void EmitContinuousWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        // Start worker immediately - host has already started");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"                var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"                var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        sb.AppendLine("                while (!token.IsCancellationRequested)");
        sb.AppendLine("                {");
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                    await (({delegateType})registration.Action)({paramNames});");
        
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (Exception ex)");
        sb.AppendLine("            {");
        sb.AppendLine("                Console.WriteLine($\"Worker error: {ex}\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static void EmitPeriodicWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        var schedule = (TimeSpan)registration.Schedule!;");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            var timer = new PeriodicTimer(schedule);");
        sb.AppendLine("            while (await timer.WaitForNextTickAsync(token))");
        sb.AppendLine("            {");
        sb.AppendLine("                using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"                var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"                var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                await (({delegateType})registration.Action)({paramNames});");
        
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static void EmitCronWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        var cronExpression = (string)registration.Schedule!;");
        sb.AppendLine("        var schedule = NCrontab.CrontabSchedule.Parse(cronExpression);");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            while (!token.IsCancellationRequested)");
        sb.AppendLine("            {");
        sb.AppendLine("                var nextRun = schedule.GetNextOccurrence(DateTime.UtcNow);");
        sb.AppendLine("                var delay = nextRun - DateTime.UtcNow;");
        sb.AppendLine();
        sb.AppendLine("                if (delay > TimeSpan.Zero)");
        sb.AppendLine("                {");
        sb.AppendLine("                    try");
        sb.AppendLine("                    {");
        sb.AppendLine("                        await Task.Delay(delay, token);");
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (TaskCanceledException)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        break;");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine();
        sb.AppendLine("                using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"                var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"                var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                await (({delegateType})registration.Action)({paramNames});");
        
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static string GetDelegateType(WorkerInvocationModel worker)
    {
        var paramTypes = string.Join(", ", worker.Parameters.Select(p => p.Type));
        if (string.IsNullOrEmpty(paramTypes))
        {
            return $"Func<{worker.ReturnType}>";
        }
        return $"Func<{paramTypes}, {worker.ReturnType}>";
    }
}
