using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MinimalWorker.Generators;

/// <summary>
/// Emits strongly-typed, AOT-compatible code for background workers.
/// No reflection - generates direct method calls with DI resolution.
/// </summary>
internal static class WorkerEmitter
{
    public static string EmitSource(List<WorkerInvocationModel> workers)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// MinimalWorker Source Generator");
        sb.AppendLine("// AOT-compatible background worker registration");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Diagnostics;");
        sb.AppendLine("using System.Diagnostics.Metrics;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.Hosting;");
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.AppendLine();
        sb.AppendLine("namespace MinimalWorker;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Extension methods for Activity to support exception recording.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class ActivityExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Records an exception on the activity following OpenTelemetry semantic conventions.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static void RecordException(this Activity? activity, Exception exception)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (activity == null) return;");
        sb.AppendLine();
        sb.AppendLine("        // Cache exception type to avoid multiple reflection calls");
        sb.AppendLine("        var exceptionType = exception.GetType();");
        sb.AppendLine("        activity.SetTag(\"exception.type\", exceptionType.FullName);");
        sb.AppendLine("        activity.SetTag(\"exception.message\", exception.Message);");
        sb.AppendLine();
        sb.AppendLine("        // Only allocate stacktrace string if activity is actually recording");
        sb.AppendLine("        if (activity.IsAllDataRequested)");
        sb.AppendLine("        {");
        sb.AppendLine("            activity.SetTag(\"exception.stacktrace\", exception.ToString());");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Observability instruments for MinimalWorker.");
        sb.AppendLine("/// ActivitySource and Meter are automatically consumed by OpenTelemetry when configured.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class MinimalWorkerObservability");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// ActivitySource for distributed tracing.");
        sb.AppendLine("    /// Configure with: tracerProvider.AddSource(\"MinimalWorker\")");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly ActivitySource ActivitySource = new(\"MinimalWorker\", \"3.1.0\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Meter for metrics collection.");
        sb.AppendLine("    /// Configure with: meterProvider.AddMeter(\"MinimalWorker\")");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Meter Meter = new(\"MinimalWorker\", \"3.1.0\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Counter for total worker executions.");
        sb.AppendLine("    /// Dimensions: worker.id, worker.name, worker.type");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Counter<long> ExecutionCounter = Meter.CreateCounter<long>(");
        sb.AppendLine("        \"worker.executions\",");
        sb.AppendLine("        unit: \"{execution}\",");
        sb.AppendLine("        description: \"Total number of worker executions\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Counter for total worker errors.");
        sb.AppendLine("    /// Dimensions: worker.id, worker.name, worker.type, exception.type");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Counter<long> ErrorCounter = Meter.CreateCounter<long>(");
        sb.AppendLine("        \"worker.errors\",");
        sb.AppendLine("        unit: \"{error}\",");
        sb.AppendLine("        description: \"Total number of worker errors\");");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Histogram for worker execution duration.");
        sb.AppendLine("    /// Dimensions: worker.id, worker.name, worker.type");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly Histogram<double> DurationHistogram = Meter.CreateHistogram<double>(");
        sb.AppendLine("        \"worker.duration\",");
        sb.AppendLine("        unit: \"ms\",");
        sb.AppendLine("        description: \"Duration of worker executions in milliseconds\");");
        sb.AppendLine();
        sb.AppendLine("    // Worker state tracking for observable gauges");
        sb.AppendLine("    private static readonly System.Collections.Concurrent.ConcurrentDictionary<string, WorkerState> _workerStates = new();");
        sb.AppendLine();
        sb.AppendLine("    internal sealed class WorkerState");
        sb.AppendLine("    {");
        sb.AppendLine("        public string WorkerId { get; set; } = string.Empty;");
        sb.AppendLine("        public string WorkerName { get; set; } = string.Empty;");
        sb.AppendLine("        public string WorkerType { get; set; } = string.Empty;");
        sb.AppendLine("        public bool IsActive { get; set; }");
        sb.AppendLine("        public long LastSuccessTimestamp { get; set; }");
        sb.AppendLine("        public long ConsecutiveFailures { get; set; }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    internal static void RegisterWorker(string workerId, string workerName, string workerType)");
        sb.AppendLine("    {");
        sb.AppendLine("        _workerStates[workerId] = new WorkerState");
        sb.AppendLine("        {");
        sb.AppendLine("            WorkerId = workerId,");
        sb.AppendLine("            WorkerName = workerName,");
        sb.AppendLine("            WorkerType = workerType,");
        sb.AppendLine("            IsActive = true,");
        sb.AppendLine("            LastSuccessTimestamp = 0,");
        sb.AppendLine("            ConsecutiveFailures = 0");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    internal static void RecordSuccess(string workerId)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_workerStates.TryGetValue(workerId, out var state))");
        sb.AppendLine("        {");
        sb.AppendLine("            state.LastSuccessTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds();");
        sb.AppendLine("            state.ConsecutiveFailures = 0;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    internal static void RecordFailure(string workerId)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_workerStates.TryGetValue(workerId, out var state))");
        sb.AppendLine("        {");
        sb.AppendLine("            state.ConsecutiveFailures++;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    internal static void DeactivateWorker(string workerId)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_workerStates.TryGetValue(workerId, out var state))");
        sb.AppendLine("        {");
        sb.AppendLine("            state.IsActive = false;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Observable gauge for active workers.");
        sb.AppendLine("    /// Returns 1 if worker is running, 0 if stopped.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly ObservableGauge<int> ActiveWorkersGauge = Meter.CreateObservableGauge<int>(");
        sb.AppendLine("        \"worker.active\",");
        sb.AppendLine("        GetActiveWorkerMeasurements,");
        sb.AppendLine("        unit: \"{active}\",");
        sb.AppendLine("        description: \"Number of active workers (1 = running, 0 = stopped)\");");
        sb.AppendLine();
        sb.AppendLine("    private static System.Collections.Generic.IEnumerable<Measurement<int>> GetActiveWorkerMeasurements()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Take a snapshot to avoid collection modified exception during enumeration");
        sb.AppendLine("        foreach (var state in _workerStates.Values.ToArray())");
        sb.AppendLine("        {");
        sb.AppendLine("            var tags = new TagList");
        sb.AppendLine("            {");
        sb.AppendLine("                { \"worker.id\", state.WorkerId },");
        sb.AppendLine("                { \"worker.name\", state.WorkerName },");
        sb.AppendLine("                { \"worker.type\", state.WorkerType }");
        sb.AppendLine("            };");
        sb.AppendLine("            yield return new Measurement<int>(state.IsActive ? 1 : 0, tags);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Observable gauge for last successful execution timestamp.");
        sb.AppendLine("    /// Unix timestamp of the last successful execution.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly ObservableGauge<long> LastSuccessGauge = Meter.CreateObservableGauge<long>(");
        sb.AppendLine("        \"worker.last_success_time\",");
        sb.AppendLine("        GetLastSuccessMeasurements,");
        sb.AppendLine("        unit: \"s\",");
        sb.AppendLine("        description: \"Unix timestamp of last successful worker execution\");");
        sb.AppendLine();
        sb.AppendLine("    private static System.Collections.Generic.IEnumerable<Measurement<long>> GetLastSuccessMeasurements()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Take a snapshot to avoid collection modified exception during enumeration");
        sb.AppendLine("        foreach (var state in _workerStates.Values.ToArray())");
        sb.AppendLine("        {");
        sb.AppendLine("            if (state.LastSuccessTimestamp > 0)");
        sb.AppendLine("            {");
        sb.AppendLine("                var tags = new TagList");
        sb.AppendLine("                {");
        sb.AppendLine("                    { \"worker.id\", state.WorkerId },");
        sb.AppendLine("                    { \"worker.name\", state.WorkerName },");
        sb.AppendLine("                    { \"worker.type\", state.WorkerType }");
        sb.AppendLine("                };");
        sb.AppendLine("                yield return new Measurement<long>(state.LastSuccessTimestamp, tags);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Observable gauge for consecutive failures count.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static readonly ObservableGauge<long> ConsecutiveFailuresGauge = Meter.CreateObservableGauge<long>(");
        sb.AppendLine("        \"worker.consecutive_failures\",");
        sb.AppendLine("        GetConsecutiveFailuresMeasurements,");
        sb.AppendLine("        unit: \"{failure}\",");
        sb.AppendLine("        description: \"Number of consecutive failures for each worker\");");
        sb.AppendLine();
        sb.AppendLine("    private static System.Collections.Generic.IEnumerable<Measurement<long>> GetConsecutiveFailuresMeasurements()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Take a snapshot to avoid collection modified exception during enumeration");
        sb.AppendLine("        foreach (var state in _workerStates.Values.ToArray())");
        sb.AppendLine("        {");
        sb.AppendLine("            var tags = new TagList");
        sb.AppendLine("            {");
        sb.AppendLine("                { \"worker.id\", state.WorkerId },");
        sb.AppendLine("                { \"worker.name\", state.WorkerName },");
        sb.AppendLine("                { \"worker.type\", state.WorkerType }");
        sb.AppendLine("            };");
        sb.AppendLine("            yield return new Measurement<long>(state.ConsecutiveFailures, tags);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();

        // Emit high-performance logging messages class
        EmitWorkerLogMessages(sb);

        // Emit the extension method that wires up all workers
        EmitWorkerExtension(sb, workers);
        
        return sb.ToString();
    }

    private static void EmitWorkerLogMessages(StringBuilder sb)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// High-performance, AOT-compatible logging messages for MinimalWorker.");
        sb.AppendLine("/// Uses LoggerMessage.Define for zero-allocation logging.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class WorkerLogMessages");
        sb.AppendLine("{");
        sb.AppendLine("    // Worker started messages");
        sb.AppendLine("    internal static readonly Action<ILogger, string, string, string, Exception?> WorkerStarted =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string>(LogLevel.Information, new EventId(1, \"WorkerStarted\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' started (Type: {WorkerType}, Id: {WorkerId})\");");
        sb.AppendLine();
        sb.AppendLine("    internal static readonly Action<ILogger, string, string, string, TimeSpan, Exception?> WorkerStartedWithSchedule =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string, TimeSpan>(LogLevel.Information, new EventId(2, \"WorkerStartedWithSchedule\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' started (Type: {WorkerType}, Id: {WorkerId}, Schedule: {Schedule})\");");
        sb.AppendLine();
        sb.AppendLine("    internal static readonly Action<ILogger, string, string, string, string, Exception?> WorkerStartedWithCron =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string, string>(LogLevel.Information, new EventId(3, \"WorkerStartedWithCron\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' started (Type: {WorkerType}, Id: {WorkerId}, CronExpression: {CronExpression})\");");
        sb.AppendLine();
        sb.AppendLine("    // Worker stopped message");
        sb.AppendLine("    internal static readonly Action<ILogger, string, string, string, Exception?> WorkerStopped =");
        sb.AppendLine("        LoggerMessage.Define<string, string, string>(LogLevel.Information, new EventId(4, \"WorkerStopped\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' stopped (Type: {WorkerType}, Id: {WorkerId})\");");
        sb.AppendLine();
        sb.AppendLine("    // Worker execution failed messages");
        sb.AppendLine("    internal static readonly Action<ILogger, string, long, Exception?> WorkerExecutionFailedWithIteration =");
        sb.AppendLine("        LoggerMessage.Define<string, long>(LogLevel.Error, new EventId(5, \"WorkerExecutionFailedWithIteration\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' execution failed (Iteration: {Iteration})\");");
        sb.AppendLine();
        sb.AppendLine("    internal static readonly Action<ILogger, string, Exception?> WorkerExecutionFailed =");
        sb.AppendLine("        LoggerMessage.Define<string>(LogLevel.Error, new EventId(6, \"WorkerExecutionFailed\"),");
        sb.AppendLine("            \"Worker '{WorkerName}' execution failed\");");
        sb.AppendLine();
        sb.AppendLine("    // Fatal error message");
        sb.AppendLine("    internal static readonly Action<ILogger, string, Exception?> WorkerFatalError =");
        sb.AppendLine("        LoggerMessage.Define<string>(LogLevel.Critical, new EventId(7, \"WorkerFatalError\"),");
        sb.AppendLine("            \"FATAL: Unhandled exception in background worker '{WorkerName}'. Application will terminate.\");");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitWorkerExtension(StringBuilder sb, List<WorkerInvocationModel> workers)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated class to wire up background workers using a module initializer.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class GeneratedBackgroundWorkerInitializer");
        sb.AppendLine("{");
        sb.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    internal static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Set the generated worker initializer");
        sb.AppendLine("        BackgroundWorkerExtensions._generatedWorkerInitializer = InitializeWorkers;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static void InitializeWorkers(IHost host)");
        sb.AppendLine("    {");
        sb.AppendLine("        var registrations = BackgroundWorkerExtensions._registrations");
        sb.AppendLine("            .Where(r => r.Host == host)");
        sb.AppendLine("            .ToList();");
        sb.AppendLine();
        sb.AppendLine("        // Initialize each worker based on its parameter signature");
        sb.AppendLine("        foreach (var registration in registrations)");
        sb.AppendLine("        {");
        
        // Generate a switch statement to match workers by their unique signature
        sb.AppendLine("            switch (registration.Signature)");
        sb.AppendLine("            {");
        
        // Create a case for each unique worker signature
        int caseNum = 1;
        var workerMap = new Dictionary<string, WorkerInvocationModel>();
        foreach (var worker in workers)
        {
            // Build signature from worker parameters - strip global:: prefix to match runtime format
            var paramTypes = string.Join(",", worker.Parameters.Select(p => p.Type.Replace("global::", "")));
            var signature = $"{worker.Type}:{paramTypes}";
            
            if (!workerMap.ContainsKey(signature))
            {
                workerMap[signature] = worker;
                sb.AppendLine($"                case \"{signature}\":");
                sb.AppendLine($"                    InitializeWorker_{caseNum}(registration);");
                sb.AppendLine("                    break;");
                caseNum++;
            }
        }
        
        sb.AppendLine("                default:");
        sb.AppendLine("                    // No matching worker initializer - this shouldn't happen");
        sb.AppendLine("                    break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // Emit worker initialization methods - one for each unique signature
        caseNum = 1;
        foreach (var kvp in workerMap)
        {
            EmitWorkerInitializer(sb, kvp.Value, caseNum);
            caseNum++;
        }
        
        sb.AppendLine("}");
    }

    private static void EmitWorkerInitializer(StringBuilder sb, WorkerInvocationModel worker, int workerNum)
    {
        sb.AppendLine($"    private static void InitializeWorker_{workerNum}(BackgroundWorkerExtensions.WorkerRegistration registration)");
        sb.AppendLine("    {");
        sb.AppendLine("        var host = registration.Host;");
        sb.AppendLine("        var lifetime = host.Services.GetRequiredService<IHostApplicationLifetime>();");
        sb.AppendLine();
        
        switch (worker.Type)
        {
            case WorkerType.Continuous:
                EmitContinuousWorkerInit(sb, worker);
                break;
            case WorkerType.Periodic:
                EmitPeriodicWorkerInit(sb, worker);
                break;
            case WorkerType.Cron:
                EmitCronWorkerInit(sb, worker);
                break;
        }
        
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void EmitContinuousWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        // Validate dependencies exist before starting worker (fail-fast)");
        sb.AppendLine("        using (var validationScope = host.Services.CreateScope())");
        sb.AppendLine("        {");
        
        // Validate all dependencies can be resolved
        foreach (var param in worker.Parameters)
        {
            if (!param.IsCancellationToken)
            {
                sb.AppendLine($"            _ = validationScope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Start worker immediately - host has already started");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"            var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"            var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        sb.AppendLine("            var workerId = registration.Id.ToString();");
        sb.AppendLine("            var workerName = registration.DisplayName;");
        sb.AppendLine("            var iteration = 0L;");
        sb.AppendLine();
        sb.AppendLine("            // Get logger for structured logging");
        sb.AppendLine("            var workerLogger = scope.ServiceProvider.GetService<ILoggerFactory>()?.CreateLogger($\"MinimalWorker.{workerName}\");");
        sb.AppendLine();
        sb.AppendLine("            // Register worker for status tracking");
        sb.AppendLine("            MinimalWorkerObservability.RegisterWorker(workerId, workerName, \"continuous\");");
        sb.AppendLine();
        sb.AppendLine("            // Log worker started");
        sb.AppendLine("            if (workerLogger != null) WorkerLogMessages.WorkerStarted(workerLogger, workerName, \"continuous\", workerId, null);");
        sb.AppendLine();
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                var tags = new TagList");
        sb.AppendLine("                {");
        sb.AppendLine("                    { \"worker.id\", workerId },");
        sb.AppendLine("                    { \"worker.name\", workerName },");
        sb.AppendLine("                    { \"worker.type\", \"continuous\" }");
        sb.AppendLine("                };");
        sb.AppendLine("                while (!token.IsCancellationRequested)");
        sb.AppendLine("                {");
        sb.AppendLine("                    iteration++;");
        sb.AppendLine("                    using var activity = MinimalWorkerObservability.ActivitySource.StartActivity(\"worker.execute\");");
        sb.AppendLine("                    activity?.SetTag(\"worker.id\", workerId);");
        sb.AppendLine("                    activity?.SetTag(\"worker.name\", workerName);");
        sb.AppendLine("                    activity?.SetTag(\"worker.type\", \"continuous\");");
        sb.AppendLine("                    activity?.SetTag(\"worker.iteration\", iteration);");
        sb.AppendLine();
        sb.AppendLine("                    var stopwatch = Stopwatch.StartNew();");
        sb.AppendLine();
        sb.AppendLine("                    try");
        sb.AppendLine("                    {");
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                        await (({delegateType})registration.Action)({paramNames});");
        sb.AppendLine();
        sb.AppendLine("                        MinimalWorkerObservability.ExecutionCounter.Add(1, tags);");
        sb.AppendLine("                        MinimalWorkerObservability.RecordSuccess(workerId);");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Ok);");

        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (OperationCanceledException)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        // Graceful shutdown - exit without error");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Ok);");
        sb.AppendLine("                        break;");
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (Exception ex)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Error, ex.Message);");
        sb.AppendLine("                        activity?.RecordException(ex);");
        sb.AppendLine();
        sb.AppendLine("                        var errorTags = new TagList");
        sb.AppendLine("                        {");
        sb.AppendLine("                            { \"worker.id\", workerId },");
        sb.AppendLine("                            { \"worker.name\", workerName },");
        sb.AppendLine("                            { \"worker.type\", \"continuous\" },");
        sb.AppendLine("                            { \"exception.type\", ex.GetType().FullName }");
        sb.AppendLine("                        };");
        sb.AppendLine("                        MinimalWorkerObservability.ErrorCounter.Add(1, errorTags);");
        sb.AppendLine("                        MinimalWorkerObservability.RecordFailure(workerId);");
        sb.AppendLine();
        sb.AppendLine("                        // Log error");
        sb.AppendLine("                        if (workerLogger != null) WorkerLogMessages.WorkerExecutionFailedWithIteration(workerLogger, workerName, iteration, ex);");
        sb.AppendLine();
        sb.AppendLine("                        if (registration.OnError != null)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            registration.OnError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        else");
        sb.AppendLine("                        {");
        sb.AppendLine("                            // No error handler provided - crash the app (fail-fast)");
        sb.AppendLine("                            if (workerLogger != null) WorkerLogMessages.WorkerFatalError(workerLogger, workerName, ex);");
        sb.AppendLine("                            ");
        sb.AppendLine("                            // Terminate the application immediately");
        sb.AppendLine("                            BackgroundWorkerExtensions.TerminateOnFatalError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine("                    finally");
        sb.AppendLine("                    {");
        sb.AppendLine("                        stopwatch.Stop();");
        sb.AppendLine("                        MinimalWorkerObservability.DurationHistogram.Record(stopwatch.Elapsed.TotalMilliseconds, tags);");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            finally");
        sb.AppendLine("            {");
        sb.AppendLine("                // Deactivate worker when it stops");
        sb.AppendLine("                MinimalWorkerObservability.DeactivateWorker(workerId);");
        sb.AppendLine("                if (workerLogger != null) WorkerLogMessages.WorkerStopped(workerLogger, workerName, \"continuous\", workerId, null);");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static void EmitPeriodicWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        // Validate dependencies exist before starting worker (fail-fast)");
        sb.AppendLine("        using (var validationScope = host.Services.CreateScope())");
        sb.AppendLine("        {");
        
        // Validate all dependencies can be resolved
        foreach (var param in worker.Parameters)
        {
            if (!param.IsCancellationToken)
            {
                sb.AppendLine($"            _ = validationScope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        var schedule = (TimeSpan)registration.Schedule!;");
        sb.AppendLine("        var workerId = registration.Id.ToString();");
        sb.AppendLine("        var workerName = registration.DisplayName;");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine();
        sb.AppendLine("        // Get logger for structured logging");
        sb.AppendLine("        var workerLogger = host.Services.GetService<ILoggerFactory>()?.CreateLogger($\"MinimalWorker.{workerName}\");");
        sb.AppendLine();
        sb.AppendLine("        // Register worker for status tracking");
        sb.AppendLine("        MinimalWorkerObservability.RegisterWorker(workerId, workerName, \"periodic\");");
        sb.AppendLine();
        sb.AppendLine("        // Log worker started");
        sb.AppendLine("        if (workerLogger != null) WorkerLogMessages.WorkerStartedWithSchedule(workerLogger, workerName, \"periodic\", workerId, schedule, null);");
        sb.AppendLine();
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            // Pre-allocate tags outside loop to avoid per-iteration allocation");
        sb.AppendLine("            var tags = new TagList");
        sb.AppendLine("            {");
        sb.AppendLine("                { \"worker.id\", workerId },");
        sb.AppendLine("                { \"worker.name\", workerName },");
        sb.AppendLine("                { \"worker.type\", \"periodic\" }");
        sb.AppendLine("            };");
        sb.AppendLine("            var scheduleString = schedule.ToString();");
        sb.AppendLine();
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                using var timer = new PeriodicTimer(schedule);");
        sb.AppendLine("                while (await timer.WaitForNextTickAsync(token))");
        sb.AppendLine("                {");
        sb.AppendLine("                    using var activity = MinimalWorkerObservability.ActivitySource.StartActivity(\"worker.execute\");");
        sb.AppendLine("                    activity?.SetTag(\"worker.id\", workerId);");
        sb.AppendLine("                    activity?.SetTag(\"worker.name\", workerName);");
        sb.AppendLine("                    activity?.SetTag(\"worker.type\", \"periodic\");");
        sb.AppendLine("                    activity?.SetTag(\"worker.schedule\", scheduleString);");
        sb.AppendLine();
        sb.AppendLine("                    var stopwatch = Stopwatch.StartNew();");
        sb.AppendLine();
        sb.AppendLine("                    try");
        sb.AppendLine("                    {");
        sb.AppendLine("                        using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"                        var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"                        var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                        await (({delegateType})registration.Action)({paramNames});");
        sb.AppendLine();
        sb.AppendLine("                        MinimalWorkerObservability.ExecutionCounter.Add(1, tags);");
        sb.AppendLine("                        MinimalWorkerObservability.RecordSuccess(workerId);");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Ok);");

        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (OperationCanceledException)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        // Graceful shutdown - exit without error");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Ok);");
        sb.AppendLine("                        break;");
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (Exception ex)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Error, ex.Message);");
        sb.AppendLine("                        activity?.RecordException(ex);");
        sb.AppendLine();
        sb.AppendLine("                        var errorTags = new TagList");
        sb.AppendLine("                        {");
        sb.AppendLine("                            { \"worker.id\", workerId },");
        sb.AppendLine("                            { \"worker.name\", workerName },");
        sb.AppendLine("                            { \"worker.type\", \"periodic\" },");
        sb.AppendLine("                            { \"exception.type\", ex.GetType().FullName }");
        sb.AppendLine("                        };");
        sb.AppendLine("                        MinimalWorkerObservability.ErrorCounter.Add(1, errorTags);");
        sb.AppendLine("                        MinimalWorkerObservability.RecordFailure(workerId);");
        sb.AppendLine();
        sb.AppendLine("                        // Log error");
        sb.AppendLine("                        if (workerLogger != null) WorkerLogMessages.WorkerExecutionFailed(workerLogger, workerName, ex);");
        sb.AppendLine();
        sb.AppendLine("                        if (registration.OnError != null)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            registration.OnError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        else");
        sb.AppendLine("                        {");
        sb.AppendLine("                            // No error handler provided - crash the app (fail-fast)");
        sb.AppendLine("                            if (workerLogger != null) WorkerLogMessages.WorkerFatalError(workerLogger, workerName, ex);");
        sb.AppendLine("                            ");
        sb.AppendLine("                            // Terminate the application immediately");
        sb.AppendLine("                            BackgroundWorkerExtensions.TerminateOnFatalError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine("                    finally");
        sb.AppendLine("                    {");
        sb.AppendLine("                        stopwatch.Stop();");
        sb.AppendLine("                        MinimalWorkerObservability.DurationHistogram.Record(stopwatch.Elapsed.TotalMilliseconds, tags);");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (OperationCanceledException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Graceful shutdown - exit without error");
        sb.AppendLine("            }");
        sb.AppendLine("            finally");
        sb.AppendLine("            {");
        sb.AppendLine("                // Deactivate worker when it stops");
        sb.AppendLine("                MinimalWorkerObservability.DeactivateWorker(workerId);");
        sb.AppendLine("                if (workerLogger != null) WorkerLogMessages.WorkerStopped(workerLogger, workerName, \"periodic\", workerId, null);");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static void EmitCronWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        // Validate dependencies exist before starting worker (fail-fast)");
        sb.AppendLine("        using (var validationScope = host.Services.CreateScope())");
        sb.AppendLine("        {");
        
        // Validate all dependencies can be resolved
        foreach (var param in worker.Parameters)
        {
            if (!param.IsCancellationToken)
            {
                sb.AppendLine($"            _ = validationScope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        var cronExpression = (string)registration.Schedule!;");
        sb.AppendLine("        var schedule = NCrontab.CrontabSchedule.Parse(cronExpression);");
        sb.AppendLine("        var workerId = registration.Id.ToString();");
        sb.AppendLine("        var workerName = registration.DisplayName;");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine();
        sb.AppendLine("        // Get logger for structured logging");
        sb.AppendLine("        var workerLogger = host.Services.GetService<ILoggerFactory>()?.CreateLogger($\"MinimalWorker.{workerName}\");");
        sb.AppendLine();
        sb.AppendLine("        // Register worker for status tracking");
        sb.AppendLine("        MinimalWorkerObservability.RegisterWorker(workerId, workerName, \"cron\");");
        sb.AppendLine();
        sb.AppendLine("        // Log worker started");
        sb.AppendLine("        if (workerLogger != null) WorkerLogMessages.WorkerStartedWithCron(workerLogger, workerName, \"cron\", workerId, cronExpression, null);");
        sb.AppendLine();
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            // Pre-allocate tags outside loop to avoid per-iteration allocation");
        sb.AppendLine("            var tags = new TagList");
        sb.AppendLine("            {");
        sb.AppendLine("                { \"worker.id\", workerId },");
        sb.AppendLine("                { \"worker.name\", workerName },");
        sb.AppendLine("                { \"worker.type\", \"cron\" }");
        sb.AppendLine("            };");
        sb.AppendLine();
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                while (!token.IsCancellationRequested)");
        sb.AppendLine("                {");
        sb.AppendLine("                    var now = DateTime.UtcNow;");
        sb.AppendLine("                    var nextRun = schedule.GetNextOccurrence(now);");
        sb.AppendLine("                    var delay = nextRun - now;");
        sb.AppendLine();
        sb.AppendLine("                    if (delay > TimeSpan.Zero)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        try");
        sb.AppendLine("                        {");
        sb.AppendLine("                            await Task.Delay(delay, token);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        catch (OperationCanceledException)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine();
        sb.AppendLine("                    using var activity = MinimalWorkerObservability.ActivitySource.StartActivity(\"worker.execute\");");
        sb.AppendLine("                    activity?.SetTag(\"worker.id\", workerId);");
        sb.AppendLine("                    activity?.SetTag(\"worker.name\", workerName);");
        sb.AppendLine("                    activity?.SetTag(\"worker.type\", \"cron\");");
        sb.AppendLine("                    activity?.SetTag(\"cron.expression\", cronExpression);");
        sb.AppendLine("                    activity?.SetTag(\"cron.next_run\", nextRun.ToString(\"o\"));");
        sb.AppendLine();
        sb.AppendLine("                    var stopwatch = Stopwatch.StartNew();");
        sb.AppendLine();
        sb.AppendLine("                    try");
        sb.AppendLine("                    {");
        sb.AppendLine("                        using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"                        var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"                        var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                        await (({delegateType})registration.Action)({paramNames});");
        sb.AppendLine();
        sb.AppendLine("                        MinimalWorkerObservability.ExecutionCounter.Add(1, tags);");
        sb.AppendLine("                        MinimalWorkerObservability.RecordSuccess(workerId);");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Ok);");

        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (OperationCanceledException)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        // Graceful shutdown - exit without error");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Ok);");
        sb.AppendLine("                        break;");
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (Exception ex)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        activity?.SetStatus(ActivityStatusCode.Error, ex.Message);");
        sb.AppendLine("                        activity?.RecordException(ex);");
        sb.AppendLine();
        sb.AppendLine("                        var errorTags = new TagList");
        sb.AppendLine("                        {");
        sb.AppendLine("                            { \"worker.id\", workerId },");
        sb.AppendLine("                            { \"worker.name\", workerName },");
        sb.AppendLine("                            { \"worker.type\", \"cron\" },");
        sb.AppendLine("                            { \"exception.type\", ex.GetType().FullName }");
        sb.AppendLine("                        };");
        sb.AppendLine("                        MinimalWorkerObservability.ErrorCounter.Add(1, errorTags);");
        sb.AppendLine("                        MinimalWorkerObservability.RecordFailure(workerId);");
        sb.AppendLine();
        sb.AppendLine("                        // Log error");
        sb.AppendLine("                        if (workerLogger != null) WorkerLogMessages.WorkerExecutionFailed(workerLogger, workerName, ex);");
        sb.AppendLine();
        sb.AppendLine("                        if (registration.OnError != null)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            registration.OnError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        else");
        sb.AppendLine("                        {");
        sb.AppendLine("                            // No error handler provided - crash the app (fail-fast)");
        sb.AppendLine("                            if (workerLogger != null) WorkerLogMessages.WorkerFatalError(workerLogger, workerName, ex);");
        sb.AppendLine("                            ");
        sb.AppendLine("                            // Terminate the application immediately");
        sb.AppendLine("                            BackgroundWorkerExtensions.TerminateOnFatalError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine("                    finally");
        sb.AppendLine("                    {");
        sb.AppendLine("                        stopwatch.Stop();");
        sb.AppendLine("                        MinimalWorkerObservability.DurationHistogram.Record(stopwatch.Elapsed.TotalMilliseconds, tags);");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (OperationCanceledException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Graceful shutdown - exit without error");
        sb.AppendLine("            }");
        sb.AppendLine("            finally");
        sb.AppendLine("            {");
        sb.AppendLine("                // Deactivate worker when it stops");
        sb.AppendLine("                MinimalWorkerObservability.DeactivateWorker(workerId);");
        sb.AppendLine("                if (workerLogger != null) WorkerLogMessages.WorkerStopped(workerLogger, workerName, \"cron\", workerId, null);");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static string GetDelegateType(WorkerInvocationModel worker)
    {
        var paramTypes = string.Join(", ", worker.Parameters.Select(p => p.Type));
        if (string.IsNullOrEmpty(paramTypes))
        {
            return $"Func<{worker.ReturnType}>";
        }
        return $"Func<{paramTypes}, {worker.ReturnType}>";
    }
}
