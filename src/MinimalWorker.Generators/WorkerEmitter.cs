using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MinimalWorker.Generators;

/// <summary>
/// Emits strongly-typed, AOT-compatible code for background workers.
/// No reflection - generates direct method calls with DI resolution.
/// </summary>
internal static class WorkerEmitter
{
    public static string EmitSource(List<WorkerInvocationModel> workers)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// MinimalWorker Source Generator");
        sb.AppendLine("// AOT-compatible background worker registration");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.Hosting;");
        sb.AppendLine();
        sb.AppendLine("namespace MinimalWorker;");
        sb.AppendLine();
        
        // Emit the extension method that wires up all workers
        EmitWorkerExtension(sb, workers);
        
        return sb.ToString();
    }

    private static void EmitWorkerExtension(StringBuilder sb, List<WorkerInvocationModel> workers)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated class to wire up background workers using a module initializer.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class GeneratedBackgroundWorkerInitializer");
        sb.AppendLine("{");
        sb.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    internal static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Set the generated worker initializer");
        sb.AppendLine("        BackgroundWorkerExtensions._generatedWorkerInitializer = InitializeWorkers;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static void InitializeWorkers(IHost host)");
        sb.AppendLine("    {");
        sb.AppendLine("        var registrations = BackgroundWorkerExtensions._registrations");
        sb.AppendLine("            .Where(r => r.Host == host)");
        sb.AppendLine("            .ToList();");
        sb.AppendLine();
        sb.AppendLine("        // Initialize each worker based on its parameter signature");
        sb.AppendLine("        foreach (var registration in registrations)");
        sb.AppendLine("        {");
        
        // Generate a switch statement to match workers by their unique signature
        sb.AppendLine("            switch (registration.Signature)");
        sb.AppendLine("            {");
        
        // Create a case for each unique worker signature
        int caseNum = 1;
        var workerMap = new Dictionary<string, WorkerInvocationModel>();
        foreach (var worker in workers)
        {
            // Build signature from worker parameters - strip global:: prefix to match runtime format
            var paramTypes = string.Join(",", worker.Parameters.Select(p => p.Type.Replace("global::", "")));
            var signature = $"{worker.Type}:{paramTypes}";
            
            if (!workerMap.ContainsKey(signature))
            {
                workerMap[signature] = worker;
                sb.AppendLine($"                case \"{signature}\":");
                sb.AppendLine($"                    InitializeWorker_{caseNum}(registration);");
                sb.AppendLine("                    break;");
                caseNum++;
            }
        }
        
        sb.AppendLine("                default:");
        sb.AppendLine("                    // No matching worker initializer - this shouldn't happen");
        sb.AppendLine("                    break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // Emit worker initialization methods - one for each unique signature
        caseNum = 1;
        foreach (var kvp in workerMap)
        {
            EmitWorkerInitializer(sb, kvp.Value, caseNum);
            caseNum++;
        }
        
        sb.AppendLine("}");
    }

    private static void EmitWorkerInitializer(StringBuilder sb, WorkerInvocationModel worker, int workerNum)
    {
        sb.AppendLine($"    private static void InitializeWorker_{workerNum}(BackgroundWorkerExtensions.WorkerRegistration registration)");
        sb.AppendLine("    {");
        sb.AppendLine("        var host = registration.Host;");
        sb.AppendLine("        var lifetime = host.Services.GetRequiredService<IHostApplicationLifetime>();");
        sb.AppendLine();
        
        switch (worker.Type)
        {
            case WorkerType.Continuous:
                EmitContinuousWorkerInit(sb, worker);
                break;
            case WorkerType.Periodic:
                EmitPeriodicWorkerInit(sb, worker);
                break;
            case WorkerType.Cron:
                EmitCronWorkerInit(sb, worker);
                break;
        }
        
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void EmitContinuousWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        // Validate dependencies exist before starting worker (fail-fast)");
        sb.AppendLine("        using (var validationScope = host.Services.CreateScope())");
        sb.AppendLine("        {");
        
        // Validate all dependencies can be resolved
        foreach (var param in worker.Parameters)
        {
            if (!param.IsCancellationToken)
            {
                sb.AppendLine($"            _ = validationScope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Start worker immediately - host has already started");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"            var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"            var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        sb.AppendLine("            while (!token.IsCancellationRequested)");
        sb.AppendLine("            {");
        sb.AppendLine("                try");
        sb.AppendLine("                {");
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                    await (({delegateType})registration.Action)({paramNames});");
        
        sb.AppendLine("                }");
        sb.AppendLine("                catch (OperationCanceledException)");
        sb.AppendLine("                {");
        sb.AppendLine("                    // Graceful shutdown - exit without error");
        sb.AppendLine("                    break;");
        sb.AppendLine("                }");
        sb.AppendLine("                catch (Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine("                    if (registration.OnError != null)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        registration.OnError(ex);");
        sb.AppendLine("                    }");
        sb.AppendLine("                    else");
        sb.AppendLine("                    {");
        sb.AppendLine("                        throw;");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static void EmitPeriodicWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        // Validate dependencies exist before starting worker (fail-fast)");
        sb.AppendLine("        using (var validationScope = host.Services.CreateScope())");
        sb.AppendLine("        {");
        
        // Validate all dependencies can be resolved
        foreach (var param in worker.Parameters)
        {
            if (!param.IsCancellationToken)
            {
                sb.AppendLine($"            _ = validationScope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        var schedule = (TimeSpan)registration.Schedule!;");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                var timer = new PeriodicTimer(schedule);");
        sb.AppendLine("                while (await timer.WaitForNextTickAsync(token))");
        sb.AppendLine("                {");
        sb.AppendLine("                    try");
        sb.AppendLine("                    {");
        sb.AppendLine("                        using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"                        var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"                        var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                        await (({delegateType})registration.Action)({paramNames});");
        
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (OperationCanceledException)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        // Graceful shutdown - exit without error");
        sb.AppendLine("                        break;");
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (Exception ex)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        if (registration.OnError != null)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            registration.OnError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        else");
        sb.AppendLine("                        {");
        sb.AppendLine("                            throw;");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (OperationCanceledException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Graceful shutdown - exit without error");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static void EmitCronWorkerInit(StringBuilder sb, WorkerInvocationModel worker)
    {
        var delegateType = GetDelegateType(worker);
        
        sb.AppendLine("        // Validate dependencies exist before starting worker (fail-fast)");
        sb.AppendLine("        using (var validationScope = host.Services.CreateScope())");
        sb.AppendLine("        {");
        
        // Validate all dependencies can be resolved
        foreach (var param in worker.Parameters)
        {
            if (!param.IsCancellationToken)
            {
                sb.AppendLine($"            _ = validationScope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        var cronExpression = (string)registration.Schedule!;");
        sb.AppendLine("        var schedule = NCrontab.CrontabSchedule.Parse(cronExpression);");
        sb.AppendLine("        var token = lifetime.ApplicationStopping;");
        sb.AppendLine("        _ = Task.Run(async () =>");
        sb.AppendLine("        {");
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine("                while (!token.IsCancellationRequested)");
        sb.AppendLine("                {");
        sb.AppendLine("                    var nextRun = schedule.GetNextOccurrence(DateTime.UtcNow);");
        sb.AppendLine("                    var delay = nextRun - DateTime.UtcNow;");
        sb.AppendLine();
        sb.AppendLine("                    if (delay > TimeSpan.Zero)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        try");
        sb.AppendLine("                        {");
        sb.AppendLine("                            await Task.Delay(delay, token);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        catch (OperationCanceledException)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            break;");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine();
        sb.AppendLine("                    try");
        sb.AppendLine("                    {");
        sb.AppendLine("                        using var scope = host.Services.CreateScope();");
        
        // Generate DI resolution
        foreach (var param in worker.Parameters)
        {
            if (param.IsCancellationToken)
            {
                sb.AppendLine($"                        var {param.Name} = token;");
            }
            else
            {
                sb.AppendLine($"                        var {param.Name} = scope.ServiceProvider.GetRequiredService<{param.Type}>();");
            }
        }
        
        sb.AppendLine();
        
        // Invoke the delegate
        var paramNames = string.Join(", ", worker.Parameters.Select(p => p.Name));
        sb.AppendLine($"                        await (({delegateType})registration.Action)({paramNames});");
        
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (OperationCanceledException)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        // Graceful shutdown - exit without error");
        sb.AppendLine("                        break;");
        sb.AppendLine("                    }");
        sb.AppendLine("                    catch (Exception ex)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        if (registration.OnError != null)");
        sb.AppendLine("                        {");
        sb.AppendLine("                            registration.OnError(ex);");
        sb.AppendLine("                        }");
        sb.AppendLine("                        else");
        sb.AppendLine("                        {");
        sb.AppendLine("                            throw;");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (OperationCanceledException)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Graceful shutdown - exit without error");
        sb.AppendLine("            }");
        sb.AppendLine("        }, token);");
    }

    private static string GetDelegateType(WorkerInvocationModel worker)
    {
        var paramTypes = string.Join(", ", worker.Parameters.Select(p => p.Type));
        if (string.IsNullOrEmpty(paramTypes))
        {
            return $"Func<{worker.ReturnType}>";
        }
        return $"Func<{paramTypes}, {worker.ReturnType}>";
    }
}
